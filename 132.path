diff --git a/frameworks/js/avrecorder/avrecorder_napi.cpp b/frameworks/js/avrecorder/avrecorder_napi.cpp
index 768e6098f..a0f5e62a2 100644
--- a/frameworks/js/avrecorder/avrecorder_napi.cpp
+++ b/frameworks/js/avrecorder/avrecorder_napi.cpp
@@ -85,6 +85,8 @@ napi_value AVRecorderNapi::Init(napi_env env, napi_value exports)
         DECLARE_NAPI_FUNCTION("getCurrentAudioCapturerInfo", JsGetCurrentAudioCapturerInfo),
         DECLARE_NAPI_FUNCTION("getAudioCapturerMaxAmplitude", JsGetAudioCapturerMaxAmplitude),
         DECLARE_NAPI_FUNCTION("getAvailableEncoder", JsGetAvailableEncoder),
+        DECLARE_NAPI_FUNCTION("setWatermark", JsSetWatermark),
+        DECLARE_NAPI_FUNCTION("isWatermarkSupported", JsIsWatermarkSupported),
 
         DECLARE_NAPI_GETTER("state", JsGetState),
     };
@@ -329,6 +331,57 @@ napi_value AVRecorderNapi::JsSetOrientationHint(napi_env env, napi_callback_info
     return result;
 }
 
+napi_value AVRecorderNapi::JsSetWatermark(napi_env env, napi_callback_info info)
+{
+    MediaTrace trace("AVRecorder::JsSetWatermark");
+    const std::string &opt = AVRecordergOpt::SET_WATERMARK;
+    MEDIA_LOGI("Js %{public}s Start", opt.c_str());
+
+    const int32_t maxParam = 2; // pixelMap + WatermarkConfig
+    size_t argCount = maxParam;
+    napi_value args[maxParam] = { nullptr };
+
+    napi_value result = nullptr;
+    napi_get_undefined(env, &result);
+
+    auto asyncCtx = std::make_unique<AVRecorderAsyncContext>(env);
+    CHECK_AND_RETURN_RET_LOG(asyncCtx != nullptr, result, "failed to get AsyncContext");
+    asyncCtx->napi = AVRecorderNapi::GetJsInstanceAndArgs(env, info, argCount, args);
+    CHECK_AND_RETURN_RET_LOG(asyncCtx->napi != nullptr, result, "failed to GetJsInstanceAndArgs");
+    CHECK_AND_RETURN_RET_LOG(asyncCtx->napi->taskQue_ != nullptr, result, "taskQue is nullptr!");
+
+    asyncCtx->deferred = CommonNapi::CreatePromise(env, nullptr, result);
+
+    if (asyncCtx->napi->CheckStateMachine(opt) == MSERR_OK) {
+        if (asyncCtx->napi->GetWatermarkParameter(asyncCtx, env, args) == MSERR_OK) {
+            asyncCtx->task_ = AVRecorderNapi::SetWatermarkTask(asyncCtx);
+            (void)asyncCtx->napi->taskQue_->EnqueueTask(asyncCtx->task_);
+        }
+    } else {
+        asyncCtx->AVRecorderSignError(MSERR_INVALID_OPERATION, opt, "");
+    }
+
+    napi_value resource = nullptr;
+    napi_create_string_utf8(env, opt.c_str(), NAPI_AUTO_LENGTH, &resource);
+    NAPI_CALL(env, napi_create_async_work(env, nullptr, resource, [](napi_env env, void* data) {
+        AVRecorderAsyncContext* asyncCtx = reinterpret_cast<AVRecorderAsyncContext *>(data);
+        CHECK_AND_RETURN_LOG(asyncCtx != nullptr, "asyncCtx is nullptr!");
+
+        if (asyncCtx->task_) {
+            auto result = asyncCtx->task_->GetResult();
+            if (result.Value().first != MSERR_EXT_API9_OK) {
+                asyncCtx->SignError(result.Value().first, result.Value().second);
+            }
+        }
+        MEDIA_LOGI("The js thread of setWatermark finishes execution and returns");
+    }, MediaAsyncContext::CompleteCallback, static_cast<void *>(asyncCtx.get()), &asyncCtx->work));
+    NAPI_CALL(env, napi_queue_async_work_with_qos(env, asyncCtx->work, napi_qos_user_initiated));
+    asyncCtx.release();
+
+    MEDIA_LOGI("Js %{public}s End", opt.c_str());
+    return result;
+}
+
 std::shared_ptr<TaskHandler<RetInfo>> AVRecorderNapi::GetPrepareTask(std::unique_ptr<AVRecorderAsyncContext> &asyncCtx)
 {
     return std::make_shared<TaskHandler<RetInfo>>([napi = asyncCtx->napi, config = asyncCtx->config_]() {
@@ -903,6 +956,58 @@ napi_value AVRecorderNapi::JsGetState(napi_env env, napi_callback_info info)
     return jsResult;
 }
 
+napi_value AVRecorderNapi::JsIsWatermarkSupported(napi_env env, napi_callback_info info)
+{
+    MediaTrace trace("AVRecorderNapi::JsIsWatermarkSupported");
+    const std::string &opt = AVRecordergOpt::IS_WATERMARK_SUPPORTED;
+    MEDIA_LOGI("Js %{public}s Start", opt.c_str());
+    napi_value result = nullptr;
+    napi_get_undefined(env, &result);
+
+    size_t argCount = 1;
+    napi_value args[1] = { nullptr };
+
+    auto asyncCtx = std::make_unique<AVRecorderAsyncContext>(env);
+    CHECK_AND_RETURN_RET_LOG(asyncCtx != nullptr, result, "failed to get AsyncContext");
+    asyncCtx->napi = AVRecorderNapi::GetJsInstanceAndArgs(env, info, argCount, args);
+    CHECK_AND_RETURN_RET_LOG(asyncCtx->napi != nullptr, result, "failed to GetJsInstanceAndArgs");
+    CHECK_AND_RETURN_RET_LOG(asyncCtx->napi->taskQue_ != nullptr, result, "taskQue is nullptr!");
+
+    asyncCtx->deferred = CommonNapi::CreatePromise(env, nullptr, result);
+
+    if (asyncCtx->napi->CheckStateMachine(opt) == MSERR_OK) {
+        asyncCtx->task_ = AVRecorderNapi::IsWatermarkSupportedTask(asyncCtx);
+        (void)asyncCtx->napi->taskQue_->EnqueueTask(asyncCtx->task_);
+        asyncCtx->opt_ = opt;
+    } else {
+        asyncCtx->AVRecorderSignError(MSERR_INVALID_OPERATION, opt, "");
+    }
+
+    napi_value resource = nullptr;
+    napi_create_string_utf8(env, opt.c_str(), NAPI_AUTO_LENGTH, &resource);
+    NAPI_CALL(env, napi_create_async_work(env, nullptr, resource, [](napi_env env, void* data) {
+        AVRecorderAsyncContext* asyncCtx = reinterpret_cast<AVRecorderAsyncContext *>(data);
+        CHECK_AND_RETURN_LOG(asyncCtx != nullptr, "asyncCtx is nullptr!");
+        if (asyncCtx->task_) {
+            auto result = asyncCtx->task_->GetResult();
+            if (result.Value().first != MSERR_EXT_API9_OK) {
+                asyncCtx->SignError(result.Value().first, result.Value().second);
+            }
+
+            if ((result.Value().first == MSERR_EXT_API9_OK) &&
+                (asyncCtx->opt_ == AVRecordergOpt::IS_WATERMARK_SUPPORTED)) {
+                asyncCtx->JsResult = std::make_unique<MediaJsResultBoolean>(asyncCtx->isWatermarkSupported_);
+            }
+        }
+        MEDIA_LOGI("The js thread of prepare finishes execution and returns");
+    }, MediaAsyncContext::CompleteCallback, static_cast<void *>(asyncCtx.get()), &asyncCtx->work));
+    NAPI_CALL(env, napi_queue_async_work_with_qos(env, asyncCtx->work, napi_qos_user_initiated));
+    asyncCtx.release();
+
+    MEDIA_LOGI("Js %{public}s End", opt.c_str());
+    return result;
+}
+
 AVRecorderNapi *AVRecorderNapi::GetJsInstanceAndArgs(
     napi_env env, napi_callback_info info, size_t &argCount, napi_value *args)
 {
@@ -1094,6 +1199,64 @@ std::shared_ptr<TaskHandler<RetInfo>> AVRecorderNapi::GetEncoderInfoTask(
     });
 }
 
+std::shared_ptr<TaskHandler<RetInfo>> AVRecorderNapi::IsWatermarkSupportedTask(
+    const std::unique_ptr<AVRecorderAsyncContext> &asyncCtx)
+{
+    return std::make_shared<TaskHandler<RetInfo>>([napi = asyncCtx->napi,
+        &isWatermarkSupported = asyncCtx->isWatermarkSupported_]() {
+        const std::string &option = AVRecordergOpt::IS_WATERMARK_SUPPORTED;
+        MEDIA_LOGI("%{public}s Start", option.c_str());
+
+        CHECK_AND_RETURN_RET(napi != nullptr,
+            GetRetInfo(MSERR_INVALID_OPERATION, option, ""));
+
+        CHECK_AND_RETURN_RET(napi->CheckStateMachine(option) == MSERR_OK,
+            GetRetInfo(MSERR_INVALID_OPERATION, option, ""));
+        
+        CHECK_AND_RETURN_RET(napi->CheckRepeatOperation(option) == MSERR_OK,
+            RetInfo(MSERR_EXT_API9_OK, ""));
+
+        int32_t ret = napi->IsWatermarkSupported(isWatermarkSupported);
+        CHECK_AND_RETURN_RET_LOG(ret == MSERR_OK, GetRetInfo(MSERR_INVALID_VAL, "IsWatermarkSupportedTask", ""),
+            "IsWatermarkSupportedTask failed");
+
+        MEDIA_LOGI("%{public}s End", option.c_str());
+        return RetInfo(MSERR_EXT_API9_OK, "");
+    });
+}
+
+std::shared_ptr<TaskHandler<RetInfo>> AVRecorderNapi::SetWatermarkTask(
+    const std::unique_ptr<AVRecorderAsyncContext> &asyncCtx)
+{
+    return std::make_shared<TaskHandler<RetInfo>>([napi = asyncCtx->napi, &pixelMap = asyncCtx->pixelMap_,
+        &watermarkConfig = asyncCtx->watermarkConfig_]() {
+        const std::string &option = AVRecordergOpt::SET_WATERMARK;
+        MEDIA_LOGI("%{public}s Start", option.c_str());
+
+        CHECK_AND_RETURN_RET(napi != nullptr,
+            GetRetInfo(MSERR_INVALID_OPERATION, option, ""));
+
+        CHECK_AND_RETURN_RET(napi->CheckStateMachine(option) == MSERR_OK,
+            GetRetInfo(MSERR_INVALID_OPERATION, option, ""));
+
+        CHECK_AND_RETURN_RET(napi->CheckRepeatOperation(option) == MSERR_OK,
+            RetInfo(MSERR_EXT_API9_OK, ""));
+        bool isWatermarkSupported = false;
+        int32_t ret = napi->IsWatermarkSupported(isWatermarkSupported);
+        CHECK_AND_RETURN_RET_LOG(ret == MSERR_OK, GetRetInfo(MSERR_INVALID_OPERATION, "SetWatermarkTask", ""),
+            "IsWatermarkSupported fail");
+        CHECK_AND_RETURN_RET_LOG(isWatermarkSupported, GetRetInfo(MSERR_INVALID_VAL, "SetWatermarkTask", ""),
+            "capability not supported");
+
+        ret = napi->SetWatermark(pixelMap, watermarkConfig);
+        CHECK_AND_RETURN_RET_LOG(ret == MSERR_OK, GetRetInfo(MSERR_INVALID_VAL, "SetWatermarkTask", ""),
+            "SetWatermarkTask failed");
+
+        MEDIA_LOGI("%{public}s End", option.c_str());
+        return RetInfo(MSERR_EXT_API9_OK, "");
+    });
+}
+
 RetInfo AVRecorderNapi::GetInputSurface()
 {
     CHECK_AND_RETURN_RET_LOG(withVideo_, GetRetInfo(MSERR_INVALID_OPERATION, "GetInputSurface", "",
@@ -1224,6 +1387,86 @@ int32_t AVRecorderNapi::GetEncoderInfo(std::vector<EncoderCapabilityData> &encod
     return ret;
 }
 
+int32_t AVRecorderNapi::IsWatermarkSupported(bool &isWatermarkSupported)
+{
+    return recorder_->IsWatermarkSupported(isWatermarkSupported);
+}
+
+int32_t AVRecorderNapi::SetWatermark(std::shared_ptr<PixelMap> &pixelMap,
+    std::shared_ptr<WatermarkConfig> &watermarkConfig)
+{
+    std::shared_ptr<Meta> avBufferConfig = std::make_shared<Meta>();
+    int32_t ret = ConfigAVBufferMeta(pixelMap, watermarkConfig, avBufferConfig);
+    CHECK_AND_RETURN_RET_LOG(ret == MSERR_OK, MSERR_INVALID_VAL, "ConfigAVBufferMeta is failed");
+    sptr<SurfaceBuffer> surfaceBuffer = SurfaceBuffer::Create();
+    BufferRequestConfig bufferConfig = {
+        .width = pixelMap->GetWidth(),
+        .height = pixelMap->GetHeight(),
+        .strideAlignment = 0x8,
+        .format = static_cast<int>(pixelMap->GetPixelFormat()),
+        .usage = BUFFER_USAGE_CPU_READ | BUFFER_USAGE_CPU_WRITE | BUFFER_USAGE_MEM_DMA,
+        .timeout = 0,
+    };
+    surfaceBuffer->Alloc(bufferConfig);
+    errno_t err {0};
+    err = memcpy_s(surfaceBuffer->GetVirAddr(), pixelMap->GetByteCount(),
+        pixelMap->GetPixels(), pixelMap->GetByteCount());
+    CHECK_AND_RETURN_RET_LOG(err == 0, MSERR_INVALID_VAL, "memcpy_s failed");
+    std::shared_ptr<AVBuffer> waterMarkBuffer = AVBuffer::CreateAVBuffer(surfaceBuffer);
+    CHECK_AND_RETURN_RET_LOG(waterMarkBuffer != nullptr, MSERR_NO_MEMORY, "surfaceBuffer is nullptr");
+    waterMarkBuffer->meta_ = avBufferConfig;
+    return recorder_->SetWatermark(waterMarkBuffer);
+}
+
+int32_t AVRecorderNapi::ConfigAVBufferMeta(std::shared_ptr<PixelMap> &pixelMap,
+    std::shared_ptr<WatermarkConfig> &watermarkConfig, std::shared_ptr<Meta> &meta)
+{
+    int32_t top = watermarkConfig->top;
+    int32_t left = watermarkConfig->left;
+    int32_t watermarkWidth = pixelMap->GetWidth();
+    int32_t watermarkHeight = pixelMap->GetHeight();
+
+    switch (rotation_) {
+        case VIDEO_ROTATION_0:
+            meta->Set<Tag::VIDEO_COORDINATE_X>(left);
+            meta->Set<Tag::VIDEO_COORDINATE_Y>(top);
+            meta->Set<Tag::VIDEO_COORDINATE_W>(watermarkWidth);
+            meta->Set<Tag::VIDEO_COORDINATE_H>(watermarkHeight);
+        case VIDEO_ROTATION_90:
+            // CHECK_AND_RETURN_RET_LOG(videoFrameWidth_-top-watermarkWidth >= 0,
+            //     MSERR_INVALID_VAL, "invalid watermark");
+            meta->Set<Tag::VIDEO_COORDINATE_X>(videoFrameWidth_-top-watermarkWidth);
+            meta->Set<Tag::VIDEO_COORDINATE_Y>(left);
+            meta->Set<Tag::VIDEO_COORDINATE_W>(watermarkHeight);
+            meta->Set<Tag::VIDEO_COORDINATE_H>(watermarkWidth);
+            pixelMap->rotate(VIDEO_ROTATION_90);
+            break;
+        case VIDEO_ROTATION_180:
+            // CHECK_AND_RETURN_RET_LOG(videoFrameWidth_-left-watermarkWidth >= 0,
+            //     MSERR_INVALID_VAL, "invalid watermark");
+            // CHECK_AND_RETURN_RET_LOG(videoFrameHeight_-top-watermarkHeight >= 0,
+            //     MSERR_INVALID_VAL, "invalid watermark");
+            meta->Set<Tag::VIDEO_COORDINATE_X>(videoFrameWidth_-left-watermarkWidth);
+            meta->Set<Tag::VIDEO_COORDINATE_Y>(videoFrameHeight_-top-watermarkHeight);
+            meta->Set<Tag::VIDEO_COORDINATE_W>(watermarkWidth);
+            meta->Set<Tag::VIDEO_COORDINATE_H>(watermarkHeight);
+            pixelMap->rotate(VIDEO_ROTATION_180);
+            break;
+        case VIDEO_ROTATION_270:
+            // CHECK_AND_RETURN_RET_LOG(videoFrameHeight_ - left - watermarkWidth >= 0,
+            //     MSERR_INVALID_VAL, "invalid watermark");
+            meta->Set<Tag::VIDEO_COORDINATE_X>(top);
+            meta->Set<Tag::VIDEO_COORDINATE_Y>(videoFrameHeight_ - left - watermarkWidth);
+            meta->Set<Tag::VIDEO_COORDINATE_W>(watermarkHeight);
+            meta->Set<Tag::VIDEO_COORDINATE_H>(watermarkWidth);
+            pixelMap->rotate(VIDEO_ROTATION_270);
+            break;
+        default:
+            break;
+    }
+    return MSERR_OK;
+}
+
 int32_t AVRecorderNapi::CheckStateMachine(const std::string &opt)
 {
     auto napiCb = std::static_pointer_cast<AVRecorderCallback>(recorderCb_);
@@ -1396,8 +1639,10 @@ int32_t AVRecorderNapi::GetVideoProfile(std::unique_ptr<AVRecorderAsyncContext>
         (asyncCtx->AVRecorderSignError(ret, "GetvideoBitrate", "videoBitrate"), ret));
     CHECK_AND_RETURN_RET(CommonNapi::GetPropertyInt32(env, item, "videoFrameWidth", profile.videoFrameWidth),
         (asyncCtx->AVRecorderSignError(ret, "GetvideoFrameWidth", "videoFrameWidth"), ret));
+    videoFrameWidth_ = profile.videoFrameWidth;
     CHECK_AND_RETURN_RET(CommonNapi::GetPropertyInt32(env, item, "videoFrameHeight", profile.videoFrameHeight),
         (asyncCtx->AVRecorderSignError(ret, "GetvideoFrameHeight", "videoFrameHeight"), ret));
+    videoFrameHeight_ = profile.videoFrameHeight;
     CHECK_AND_RETURN_RET(CommonNapi::GetPropertyInt32(env, item, "videoFrameRate", profile.videoFrameRate),
         (asyncCtx->AVRecorderSignError(ret, "GetvideoFrameRate", "videoFrameRate"), ret));
     if (CommonNapi::GetPropertyBool(env, item, "isHdr", profile.isHdr)) {
@@ -1487,7 +1732,7 @@ int32_t AVRecorderNapi::GetConfig(std::unique_ptr<AVRecorderAsyncContext> &async
         config->rotation == VIDEO_ROTATION_180 || config->rotation == VIDEO_ROTATION_270),
         (asyncCtx->AVRecorderSignError(MSERR_PARAMETER_VERIFICATION_FAILED, "getrotation", "rotation",
             "rotation angle must be 0, 90, 180 or 270!"), MSERR_PARAMETER_VERIFICATION_FAILED));
-
+    rotation_ = config->rotation;
     if (CommonNapi::CheckhasNamedProperty(env, args, "location")) {
         CHECK_AND_RETURN_RET(GetLocation(asyncCtx, env, args),
             (asyncCtx->AVRecorderSignError(MSERR_INVALID_VAL, "GetLocation", "Location"), MSERR_INVALID_VAL));
@@ -1568,6 +1813,7 @@ int32_t AVRecorderNapi::GetAVMetaData(std::unique_ptr<AVRecorderAsyncContext> &a
     std::string strRotation = CommonNapi::GetPropertyString(env, metadata, "videoOrientation");
     if (strRotation == "0" || strRotation == "90" || strRotation == "180" || strRotation == "270") {
         asyncCtx->config_->rotation = std::stoi(strRotation);
+        rotation_ = asyncCtx->config_->rotation;
         MEDIA_LOGI("rotation: %{public}d", asyncCtx->config_->rotation);
     } else if (strRotation != "") {
         asyncCtx->AVRecorderSignError(MSERR_INVALID_VAL, "not support rotation", "videoOrientation");
@@ -1582,6 +1828,46 @@ int32_t AVRecorderNapi::GetAVMetaData(std::unique_ptr<AVRecorderAsyncContext> &a
     return MSERR_OK;
 }
 
+int32_t AVRecorderNapi::GetWatermarkParameter(std::unique_ptr<AVRecorderAsyncContext> &asyncCtx,
+    napi_env env, napi_value *args)
+{
+    int32_t ret = GetWatermark(asyncCtx, env, args[0]);
+    CHECK_AND_RETURN_RET_LOG(ret == MSERR_OK, ret, "failed to GetWatermark");
+    ret = GetWatermarkConfig(asyncCtx, env, args[1]);
+    CHECK_AND_RETURN_RET_LOG(ret == MSERR_OK, ret, "failed to GetWatermarkConfig");
+    return MSERR_OK;
+}
+
+int32_t AVRecorderNapi::GetWatermark(std::unique_ptr<AVRecorderAsyncContext> &asyncCtx,
+    napi_env env, napi_value args)
+{
+    CHECK_AND_RETURN_RET(CommonNapi::CheckValueType(env, args, napi_object),
+        (asyncCtx->AVRecorderSignError(MSERR_INVALID_VAL, "GetPixelMap", "PixelMap"), MSERR_INVALID_VAL));
+    asyncCtx->pixelMap_ = Media::PixelMapNapi::GetPixelMap(env, args);
+    CHECK_AND_RETURN_RET(asyncCtx->pixelMap_ != nullptr,
+        (asyncCtx->AVRecorderSignError(MSERR_INVALID_VAL, "GetPixelMap", "PixelMap"), MSERR_INVALID_VAL));
+    return MSERR_OK;
+}
+
+int32_t AVRecorderNapi::GetWatermarkConfig(std::unique_ptr<AVRecorderAsyncContext> &asyncCtx,
+    napi_env env, napi_value args)
+{
+    CHECK_AND_RETURN_RET(CommonNapi::CheckValueType(env, args, napi_object),
+        (asyncCtx->AVRecorderSignError(MSERR_INVALID_VAL, "GetWatermarkConfig", "WatermarkConfig"), MSERR_INVALID_VAL));
+    asyncCtx->watermarkConfig_ = std::make_shared<WatermarkConfig>();
+
+    bool ret = CommonNapi::GetPropertyInt32(env, args, "top", asyncCtx->watermarkConfig_->top);
+    CHECK_AND_RETURN_RET(ret && asyncCtx->watermarkConfig_->top >= 0,
+        (asyncCtx->AVRecorderSignError(MSERR_PARAMETER_VERIFICATION_FAILED, "GetWatermarkConfig", "top",
+            "config top cannot be null or less than zero"), MSERR_PARAMETER_VERIFICATION_FAILED));
+
+    ret = CommonNapi::GetPropertyInt32(env, args, "left", asyncCtx->watermarkConfig_->left);
+    CHECK_AND_RETURN_RET(ret && asyncCtx->watermarkConfig_->left >= 0,
+        (asyncCtx->AVRecorderSignError(MSERR_PARAMETER_VERIFICATION_FAILED, "GetWatermarkConfig", "left",
+            "config left cannot be null or less than zero"), MSERR_PARAMETER_VERIFICATION_FAILED));
+    return MSERR_OK;
+}
+
 bool AVRecorderNapi::GetLocation(std::unique_ptr<AVRecorderAsyncContext> &asyncCtx, napi_env env, napi_value args)
 {
     napi_value geoLocation = nullptr;