diff --git a/config.gni b/config.gni
index e8abf8c13af4e53f065cf94ca66cee40667ab9ad..829d580c52c87828e76f8d5da32608c7c44d9667 100644
--- a/config.gni
+++ b/config.gni
@@ -31,6 +31,7 @@ declare_args() {
   multimedia_player_framework_support_screen_capture = true
   multimedia_player_framework_support_screen_capture_controller = false
   multimedia_player_framework_support_jssoundpool = true
+  multimedia_player_framework_support_mediasource = true
   if (defined(build_seccomp) && build_seccomp) {
     multimedia_player_framework_support_seccomp = true
   }
diff --git a/frameworks/js/avplayer/BUILD.gn b/frameworks/js/avplayer/BUILD.gn
index daaeb68d5e12fa008b36bd805c4590e977ac5319..e6d37fd0ecb765726f86fee832e18b8602ed9b74 100644
--- a/frameworks/js/avplayer/BUILD.gn
+++ b/frameworks/js/avplayer/BUILD.gn
@@ -26,6 +26,7 @@ ohos_shared_library("media_avplayer") {
     "//foundation/multimedia/player_framework/interfaces/inner_api",
     "//foundation/multimedia/player_framework/frameworks/js/avplayer",
     "//foundation/multimedia/player_framework/frameworks/js/common",
+    "//foundation/multimedia/player_framework/frameworks/js/mediasource",
     "//foundation/multimedia/player_framework/services/utils/include",
     "//third_party/libuv/include",
   ]
@@ -35,6 +36,7 @@ ohos_shared_library("media_avplayer") {
     "//foundation/multimedia/player_framework/frameworks/js/avplayer/avplayer_callback.cpp",
     "//foundation/multimedia/player_framework/frameworks/js/avplayer/avplayer_napi.cpp",
     "//foundation/multimedia/player_framework/frameworks/js/common/common_napi.cpp",
+    "//foundation/multimedia/player_framework/frameworks/js/mediasource/media_source_napi.cpp"
   ]
 
   cflags = [
diff --git a/frameworks/js/avplayer/avplayer_napi.cpp b/frameworks/js/avplayer/avplayer_napi.cpp
index 808d9448841033dc569d1e318749a11ad31e5a44..0a38dc8ac87c14e1067566ee3e4f38a05544b15d 100644
--- a/frameworks/js/avplayer/avplayer_napi.cpp
+++ b/frameworks/js/avplayer/avplayer_napi.cpp
@@ -32,6 +32,7 @@
 #endif
 #include "av_common.h"
 #include "meta/video_types.h"
+#include "media_source_napi.h"
 
 using namespace OHOS::AudioStandard;
 
@@ -72,6 +73,7 @@ napi_value AVPlayerNapi::Init(napi_env env, napi_value exports)
         DECLARE_NAPI_FUNCTION("off", JsClearOnCallback),
         DECLARE_NAPI_FUNCTION("setVolume", JsSetVolume),
         DECLARE_NAPI_FUNCTION("setSpeed", JsSetSpeed),
+        DECLARE_NAPI_FUNCTION("setMediaSource", JsSetMediaSource),
         DECLARE_NAPI_FUNCTION("setBitrate", JsSelectBitrate),
         DECLARE_NAPI_FUNCTION("getTrackDescription", JsGetTrackDescription),
         DECLARE_NAPI_FUNCTION("selectTrack", JsSelectTrack),
@@ -168,6 +170,8 @@ void AVPlayerNapi::Destructor(napi_env env, void *nativeObject, void *finalize)
     MEDIA_LOGI("Destructor success");
 }
 
+
+
 napi_value AVPlayerNapi::JsCreateAVPlayer(napi_env env, napi_callback_info info)
 {
     MediaTrace trace("AVPlayerNapi::createAVPlayer");
@@ -1254,6 +1258,51 @@ napi_value AVPlayerNapi::JsGetAVFileDescriptor(napi_env env, napi_callback_info
     return value;
 }
 
+napi_value AVPlayerNapi::JsSetMediaSource(napi_env env, napi_callback_info info)
+{
+    MediaTrace trace("AVPlayerNapi::JsSetMediaSource");
+    napi_value result = nullptr;
+    napi_get_undefined(env, &result);
+    napi_value args[2] = { nullptr };
+    size_t argCount = 2;
+    AVPlayerNapi *jsPlayer = AVPlayerNapi::GetJsInstanceWithParameter(env, info, argCount, args);
+    CHECK_AND_RETURN_RET_LOG(jsPlayer != nullptr, result, "failed to GetJsInstanceWithParameter");
+
+    if (jsPlayer->IsLiveSource()) {
+        jsPlayer->OnErrorCb(MSERR_EXT_API9_UNSUPPORT_CAPABILITY, "The stream is live stream, not support seek");
+        return result;
+    }
+
+     napi_valuetype valueType = napi_undefined;
+     if (argCount < 2 || napi_typeof(env, args[0], &valueType) != napi_ok || valueType != napi_object
+        || napi_typeof(env, args[1], &valueType) != napi_ok || valueType != napi_object) {
+        jsPlayer->OnErrorCb(MSERR_EXT_API9_INVALID_PARAMETER, "SetMediaSource is not napi_object");
+    }
+
+    std::shared_ptr<AVMediaSource> mediaSource = MediaSourceNapi::GetMediaSource(env, args[0]);
+
+    struct AVPlayStrategy strategy;
+    if (!CommonNapi::GetPlayStrategy(env, args[1], strategy)) {
+        MEDIA_LOGE("get fileDescriptor argument failed!");
+        jsPlayer->OnErrorCb(MSERR_EXT_API9_INVALID_PARAMETER,
+            "invalid parameters, please check the input parameters(fileDescriptor)");
+        return result;
+    }
+ 
+    auto task = std::make_shared<TaskHandler<void>>([jsPlayer, mediaSource, strategy]() {
+        if (jsPlayer->player_ != nullptr) {
+            std::map<std::string, std::string> header = mediaSource->header;
+            u_int32_t preferedWidth = strategy.preferedWidth;
+            u_int32_t preferedHeight = strategy.preferedHeight;
+            u_int32_t bufferDuration =  strategy.preferedBufferDuration;
+            bool preferHDR = strategy.preferHDR;
+            (void)jsPlayer->player_->SetMediaSource(header, preferedWidth, preferedHeight, bufferDuration, preferHDR);
+        }
+    });
+    (void)jsPlayer->taskQue_->EnqueueTask(task);
+    return result;
+}
+
 napi_value AVPlayerNapi::JsSetDataSrc(napi_env env, napi_callback_info info)
 {
     MediaTrace trace("AVPlayerNapi::set dataSrc");
diff --git a/frameworks/js/avplayer/avplayer_napi.h b/frameworks/js/avplayer/avplayer_napi.h
index 4f4d4629e349d4f9874c34b02f5869e2fb3eb407..cadfdd709eedddb4c09c70a381fafcc481f9a3fe 100644
--- a/frameworks/js/avplayer/avplayer_napi.h
+++ b/frameworks/js/avplayer/avplayer_napi.h
@@ -222,6 +222,8 @@ private:
      * setDecryptionConfig(mediaKeySession: drm.MediaKeySession, secureVideoPath: boolean): void;
      */
     static napi_value JsSetDecryptConfig(napi_env env, napi_callback_info info);
+
+    static napi_value JsSetMediaSource(napi_env env, napi_callback_info info);
     /**
      * getMediaKeySystemInfos(): Array<MediaKeySystemInfo>;
      */
diff --git a/frameworks/js/common/common_napi.cpp b/frameworks/js/common/common_napi.cpp
index bb1dae179ced1ba7278442d2bb783828a4d7ba24..18ffbe577b18ce13bd223de319b29effb2a15c1d 100644
--- a/frameworks/js/common/common_napi.cpp
+++ b/frameworks/js/common/common_napi.cpp
@@ -161,6 +161,61 @@ bool CommonNapi::GetFdArgument(napi_env env, napi_value value, AVFileDescriptor
     return true;
 }
 
+bool CommonNapi::GetPropertyMap(napi_env env, napi_value value, std::map<std::string, std::string>& map)
+{
+    napi_value jsProNameList = nullptr;
+    uint32_t jsProCount = 0;
+    napi_status status = napi_get_property_names(env, value, &jsProNameList);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, false, "get property name failed");
+    status = napi_get_array_length(env, jsProNameList, &jsProCount);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, false, "get subKeys length failed");
+
+    napi_value jsProName = nullptr;
+    napi_value jsProValue = nullptr;
+    for (uint32_t i = 0; i < jsProCount; i++) {
+        status = napi_get_element(env, jsProNameList, i, &jsProName);
+        CHECK_AND_RETURN_RET_LOG(status == napi_ok, false, "get sub key failed");
+        std::string strProName = GetStringArgument(env, jsProName);
+
+        status = napi_get_named_property(env, value, strProName.c_str(), &jsProValue);
+        CHECK_AND_RETURN_RET_LOG(status == napi_ok, false, "get sub value failed");
+        std::string strProValue = GetStringArgument(env, jsProValue);
+
+        map.emplace(strProName, strProValue);
+    }
+
+    return true;
+}
+
+bool CommonNapi::GetDataSrcDescriptor(napi_env env, napi_value value, AVDataSrcDescriptor& dataSrc, napi_ref& ref)
+{
+    if (!GetPropertyInt64(env, value, "fileSize", dataSrc.fileSize)) {
+        dataSrc.fileSize = 0; // use default value
+    }
+    napi_get_named_property(env, value, "callback", &dataSrc.callback);
+    napi_status status = napi_create_reference(env, dataSrc.callback, 1, &ref);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok && ref != nullptr, false, "failed to create reference!");
+
+    return true;
+}
+
+bool CommonNapi::GetPlayStrategy(napi_env env, napi_value value, AVPlayStrategy &playStrategy)
+{
+    if (!GetPropertyUint32(env, value, "preferedWidth", playStrategy.preferedWidth)) {
+        playStrategy.preferedWidth = 0; // use default value
+    }
+    if (!GetPropertyUint32(env, value, "preferedHeight", playStrategy.preferedHeight)) {
+        playStrategy.preferedHeight = 0; // use default value
+    }
+    if (!GetPropertyUint32(env, value, "preferedBufferDuration", playStrategy.preferedBufferDuration)) {
+        playStrategy.preferedBufferDuration = 0; // use default value
+    }
+    if (!GetPropertyBool(env, value, "preferedWidth", playStrategy.preferHDR )) {
+        playStrategy.preferHDR = 0; // use default value
+    }
+    return true;
+}
+
 napi_status CommonNapi::FillErrorArgs(napi_env env, int32_t errCode, const napi_value &args)
 {
     napi_value codeStr = nullptr;
diff --git a/frameworks/js/common/common_napi.h b/frameworks/js/common/common_napi.h
index 795aa6724dbf2b84aa19048e7fe62f743dbf3420..3ea1ac103fca6092495f9c5e69122bd635f99234 100644
--- a/frameworks/js/common/common_napi.h
+++ b/frameworks/js/common/common_napi.h
@@ -16,6 +16,7 @@
 #ifndef COMMON_NAPI_H
 #define COMMON_NAPI_H
 
+#include <map>
 #include <string>
 #include <vector>
 #include <unordered_map>
@@ -30,6 +31,9 @@
 namespace OHOS {
 namespace Media {
 struct AVFileDescriptor;
+struct AVPlayStrategy;
+struct AVDataSrcDescriptor;
+class AVMediaSource;
 
 class CommonNapi {
 public:
@@ -42,7 +46,10 @@ public:
     static bool GetPropertyInt64(napi_env env, napi_value configObj, const std::string &type, int64_t &result);
     static bool GetPropertyDouble(napi_env env, napi_value configObj, const std::string &type, double &result);
     static std::string GetPropertyString(napi_env env, napi_value configObj, const std::string &type);
+    static bool GetPropertyMap(napi_env env, napi_value value, std::map<std::string, std::string>& map);
     static bool GetFdArgument(napi_env env, napi_value value, AVFileDescriptor &rawFd);
+    static bool GetDataSrcDescriptor(napi_env env, napi_value value, AVDataSrcDescriptor& dataSrc, napi_ref& ref);
+    static bool GetPlayStrategy(napi_env env, napi_value value, AVPlayStrategy &playStrategy);
     static napi_status FillErrorArgs(napi_env env, int32_t errCode, const napi_value &args);
     static napi_status CreateError(napi_env env, int32_t errCode, const std::string &errMsg, napi_value &errVal);
     static napi_ref CreateReference(napi_env env, napi_value arg);
@@ -296,6 +303,28 @@ struct AVDataSrcDescriptor {
     napi_value callback = nullptr;
 };
 
+class AVMediaSource {
+public:
+    AVMediaSource() = default;
+    ~AVMediaSource()
+    {
+        header.clear();
+        dataSrcRef = nullptr;
+    }
+    std::string url {0};
+    std::map<std::string, std::string> header;
+    AVFileDescriptor fdSrc {0};
+    AVDataSrcDescriptor dataSrc {0};
+    std::shared_ptr<AutoRef> dataSrcRef {nullptr};
+};
+
+struct AVPlayStrategy {
+    uint32_t preferedWidth;
+    uint32_t preferedHeight;
+    uint32_t preferedBufferDuration;
+    bool preferHDR; 
+};
+
 template<typename T>
 class ObjectRefMap {
 public:
diff --git a/frameworks/js/media/native_module_ohos_media.cpp b/frameworks/js/media/native_module_ohos_media.cpp
index cc9111870c6034de9379da06dbd379b27d39bc5b..b4a7e6512c249fc7d226dbcc072179d001e17584 100644
--- a/frameworks/js/media/native_module_ohos_media.cpp
+++ b/frameworks/js/media/native_module_ohos_media.cpp
@@ -51,6 +51,10 @@ static napi_value Export(napi_env env, napi_value exports)
 #ifdef SUPPORT_SOUND_POOL
     OHOS::Media::SoundPoolNapi::Init(env, exports);
 #endif
+#ifdef SUPPORT_MEDIA_SOURCE
+    OHOS::Media::MediaSourceNapi::Init(env, exports);
+#endif
+
 #ifdef SUPPORT_SCREEN_CAPTURE
     OHOS::Media::AVScreenCaptureNapi::Init(env, exports);
 #endif
diff --git a/frameworks/js/mediasource/media_source_napi.cpp b/frameworks/js/mediasource/media_source_napi.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..7e0e11c1615e65f9ae0900aa04ba9009af5951ea
--- /dev/null
+++ b/frameworks/js/mediasource/media_source_napi.cpp
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "media_source_napi.h"
+#include "media_log.h"
+
+namespace {
+    constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "MediaSourceNapi"};
+}
+
+namespace OHOS {
+namespace Media {
+
+const std::string CLASS_NAME = "MediaSource";
+thread_local napi_ref MediaSourceNapi::constructor_ = nullptr;
+
+napi_value MediaSourceNapi::Init(napi_env env, napi_value exports)
+{
+    napi_property_descriptor staticProperty[] = {
+        DECLARE_NAPI_STATIC_FUNCTION("createMediaSourceWithURL", JsCreateMediaSourceWithUrl),
+        DECLARE_NAPI_STATIC_FUNCTION("createMediaSourceWithFD", JsCreateMediaSourceWithFd),
+        DECLARE_NAPI_STATIC_FUNCTION("createMediaSourceWithDataSource", JsCreateMediaSourceWithDataSource),
+    };
+
+    napi_property_descriptor properties[] = {
+        DECLARE_NAPI_FUNCTION("setTimeRange", JsSetTimeRange),
+    };
+
+    napi_value constructor = nullptr;
+    napi_status status = napi_define_class(env, CLASS_NAME.c_str(), NAPI_AUTO_LENGTH, Constructor, nullptr,
+        sizeof(properties) / sizeof(properties[0]), properties, &constructor);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, nullptr, "Failed to define AVPlayer class");
+
+    status = napi_create_reference(env, constructor, 1, &constructor_);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, nullptr, "Failed to create reference of constructor");
+
+    status = napi_set_named_property(env, exports, CLASS_NAME.c_str(), constructor);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, nullptr, "Failed to set constructor");
+
+    status = napi_define_properties(env, exports, sizeof(staticProperty) / sizeof(staticProperty[0]), staticProperty);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, nullptr, "Failed to define static function");
+    return exports;
+}
+
+std::shared_ptr<AVMediaSource> MediaSourceNapi::GetMediaSource(napi_env env, napi_value jsMediaSource)
+{
+    MediaSourceNapi *mediaSource = nullptr;
+    napi_status status = napi_unwrap(env, jsMediaSource, reinterpret_cast<void **>(&mediaSource));
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok && mediaSource != nullptr, nullptr, "failed to napi_unwrap");
+
+    return mediaSource->mediaSource_;
+}
+
+napi_value MediaSourceNapi::Constructor(napi_env env, napi_callback_info info)
+{
+    napi_value result = nullptr;
+    napi_get_undefined(env, &result);
+
+    size_t argCount = 0;
+    napi_value jsThis = nullptr;
+    napi_status status = napi_get_cb_info(env, info, &argCount, nullptr, &jsThis, nullptr);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, result, "failed to napi_get_cb_info");
+
+    MediaSourceNapi *jsMediaSource = new(std::nothrow) MediaSourceNapi();
+    CHECK_AND_RETURN_RET_LOG(jsMediaSource != nullptr, result, "failed to new MediaSourceNapi");
+
+    jsMediaSource->env_ = env;
+    jsMediaSource->mediaSource_ = std::make_shared<AVMediaSource>();
+    CHECK_AND_RETURN_RET_LOG(jsMediaSource->mediaSource_ != nullptr, result, "failed to Create MediaSource");
+
+    status = napi_wrap(env, jsThis, reinterpret_cast<void *>(jsMediaSource),
+        MediaSourceNapi::Destructor, nullptr, nullptr);
+    if (status != napi_ok) {
+        delete jsMediaSource;
+        MEDIA_LOGE("Failed to wrap native instance");
+        return result;
+    }
+
+    MEDIA_LOGI("0x%{public}06" PRIXPTR " Constructor success", FAKE_POINTER(jsMediaSource));
+    return jsThis;
+}
+
+void MediaSourceNapi::Destructor(napi_env env, void *nativeObject, void *finalize)
+{
+    (void)env;
+    (void)finalize;
+    if (nativeObject != nullptr) {
+        MediaSourceNapi *jsMediaSource = reinterpret_cast<MediaSourceNapi *>(nativeObject);
+        jsMediaSource->mediaSource_ = nullptr;
+        delete jsMediaSource;
+    }
+    MEDIA_LOGI("Destructor success");
+}
+
+napi_value MediaSourceNapi::JsCreateMediaSourceWithUrl(napi_env env, napi_callback_info info)
+{
+    MEDIA_LOGD("JsCreateMediaSourceWithUrl In");
+    size_t argCount = 2;
+    napi_value args[2] = { nullptr };
+    napi_value jsMediaSource = nullptr;
+    napi_get_undefined(env, &jsMediaSource);
+    napi_status status = napi_get_cb_info(env, info, &argCount, args, nullptr, nullptr);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, nullptr, "failed to napi_get_cb_info");
+
+    napi_valuetype valueType = napi_undefined;
+    if (argCount < 1 || napi_typeof(env, args[0], &valueType) != napi_ok || valueType != napi_string) {
+        return nullptr;
+    }
+
+    napi_value constructor = nullptr;
+    napi_status ret = napi_get_reference_value(env, constructor_, &constructor);
+    if (ret != napi_ok || constructor == nullptr) {
+        return nullptr;
+    }
+    napi_new_instance(env, constructor, 0, nullptr, &jsMediaSource);
+
+    std::shared_ptr<AVMediaSource> mediaSource = GetMediaSource(env, jsMediaSource);
+    mediaSource->url = CommonNapi::GetStringArgument(env, args[0]);
+
+    if (argCount >= 2 && napi_typeof(env, args[1], &valueType) == napi_ok && valueType != napi_object) {
+        (void)CommonNapi::GetPropertyMap(env, args[1], mediaSource->header);
+    }
+
+    return jsMediaSource;
+}
+
+napi_value MediaSourceNapi::JsCreateMediaSourceWithFd(napi_env env, napi_callback_info info)
+{
+    MEDIA_LOGD("JsCreateMediaSourceWithFd In");
+    size_t argCount = 1;
+    napi_value args[1] = { nullptr };
+    napi_value jsMediaSource = nullptr;
+    napi_get_undefined(env, &jsMediaSource);
+    napi_status status = napi_get_cb_info(env, info, &argCount, args, nullptr, nullptr);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, nullptr, "failed to napi_get_cb_info");
+
+    napi_valuetype valueType = napi_undefined;
+    if (argCount < 1 || napi_typeof(env, args[0], &valueType) != napi_ok || valueType != napi_object) {
+        return nullptr;
+    }
+
+    napi_value constructor = nullptr;
+    napi_status ret = napi_get_reference_value(env, constructor_, &constructor);
+    if (ret != napi_ok || constructor == nullptr) {
+        return nullptr;
+    }
+    napi_new_instance(env, constructor, 0, nullptr, &jsMediaSource);
+
+    std::shared_ptr<AVMediaSource> mediaSource = GetMediaSource(env, jsMediaSource);
+    (void)CommonNapi::GetFdArgument(env, args[0], mediaSource->fdSrc);
+
+    return jsMediaSource;
+}
+
+napi_value MediaSourceNapi::JsCreateMediaSourceWithDataSource(napi_env env, napi_callback_info info)
+{
+    MEDIA_LOGD("JsCreateMediaSourceWithDataSource In");
+    size_t argCount = 1;
+    napi_value args[1] = { nullptr };
+    napi_value jsMediaSource = nullptr;
+    napi_get_undefined(env, &jsMediaSource);
+    napi_status status = napi_get_cb_info(env, info, &argCount, args, nullptr, nullptr);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, nullptr, "failed to napi_get_cb_info");
+
+    napi_valuetype valueType = napi_undefined;
+    if (argCount < 1 || napi_typeof(env, args[0], &valueType) != napi_ok || valueType != napi_object) {
+        return nullptr;
+    }
+
+    napi_value constructor = nullptr;
+    napi_status ret = napi_get_reference_value(env, constructor_, &constructor);
+    if (ret != napi_ok || constructor == nullptr) {
+        return nullptr;
+    }
+    napi_new_instance(env, constructor, 0, nullptr, &jsMediaSource);
+
+    napi_ref ref = nullptr;
+    std::shared_ptr<AVMediaSource> mediaSource = GetMediaSource(env, jsMediaSource);
+    (void)CommonNapi::GetDataSrcDescriptor(env, args[0], mediaSource->dataSrc, ref);
+
+    mediaSource->dataSrcRef = std::make_shared<AutoRef>(env, ref);
+
+    return jsMediaSource;
+}
+
+napi_value MediaSourceNapi::JsSetTimeRange(napi_env env, napi_callback_info info)
+{
+    return nullptr;
+}
+
+} // Media
+} // OHOS
\ No newline at end of file
diff --git a/frameworks/js/mediasource/media_source_napi.h b/frameworks/js/mediasource/media_source_napi.h
new file mode 100644
index 0000000000000000000000000000000000000000..c43fbe58b92c0413a3cee965930f847d755e6f04
--- /dev/null
+++ b/frameworks/js/mediasource/media_source_napi.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIA_SOURCE_NAPI_H
+#define MEDIA_SOURCE_NAPI_H
+
+#include "napi/native_api.h"
+#include "napi/native_node_api.h"
+#include "common_napi.h"
+
+namespace OHOS {
+namespace Media {
+
+class MediaSourceNapi {
+public:
+    __attribute__((visibility("default"))) static napi_value Init(napi_env env, napi_value exports);
+    static std::shared_ptr<AVMediaSource> GetMediaSource(napi_env env, napi_value jsMediaSource);
+private:
+    static napi_value Constructor(napi_env env, napi_callback_info info);
+    static void Destructor(napi_env env, void *nativeObject, void *finalize);
+    /**
+     * function createMediaSourceWithURL(url: string, header?: string): MediaSource
+     */
+    static napi_value JsCreateMediaSourceWithUrl(napi_env env, napi_callback_info info);
+    /**
+     * createMediaSourceWithFD(fdSrc: AVFileDescriptor): MediaSource
+     */
+    static napi_value JsCreateMediaSourceWithFd(napi_env env, napi_callback_info info);
+    /**
+     * createMediaSourceWithDataSource(dataSrc: AVDataSrcDescriptor): MediaSource
+     */
+    static napi_value JsCreateMediaSourceWithDataSource(napi_env env, napi_callback_info info);
+    /**
+     * setTimeRange(startTime? : number, endTime? : number): void
+     */
+    static napi_value JsSetTimeRange(napi_env env, napi_callback_info info);
+
+    MediaSourceNapi() = default;
+    virtual ~MediaSourceNapi() = default;
+
+    static thread_local napi_ref constructor_;
+    napi_env env_ = nullptr;
+    std::shared_ptr<AVMediaSource> mediaSource_ {nullptr};
+};
+
+} // Media
+} // OHOS
+
+#endif // MEDIA_SOURCE_NAPI_H
\ No newline at end of file
diff --git a/frameworks/native/player/player_impl.cpp b/frameworks/native/player/player_impl.cpp
index 2dd04b5ff1f17db46c51c0f2f34ab658b7b1a22b..b5f3e15c10b68bd9409d76c1bd56632051c7158e 100644
--- a/frameworks/native/player/player_impl.cpp
+++ b/frameworks/native/player/player_impl.cpp
@@ -222,6 +222,15 @@ int32_t PlayerImpl::SetPlaybackSpeed(PlaybackRateMode mode)
     return playerService_->SetPlaybackSpeed(mode);
 }
 
+int32_t PlayerImpl::SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+    u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) 
+{
+    MEDIA_LOGD("PlayerImpl:0x%{public}06" PRIXPTR " SetDurationSize in, mode is %{public}d", FAKE_POINTER(this),
+        bufferDuration);
+    CHECK_AND_RETURN_RET_LOG(playerService_ != nullptr, MSERR_SERVICE_DIED, "player service does not exist..");
+    return playerService_->SetMediaSource(header, preferedWidth, preferedHeight, bufferDuration, preferHDR);
+}
+
 int32_t PlayerImpl::GetPlaybackSpeed(PlaybackRateMode &mode)
 {
     MEDIA_LOGD("PlayerImpl:0x%{public}06" PRIXPTR " GetPlaybackSpeed in", FAKE_POINTER(this));
diff --git a/frameworks/native/player/player_impl.h b/frameworks/native/player/player_impl.h
index 0a1c8c5ba3d7b6b68ff4710c1d6f02f09b4c00c2..f118cf26a0688483940eb14494c2eb2695b31d1d 100644
--- a/frameworks/native/player/player_impl.h
+++ b/frameworks/native/player/player_impl.h
@@ -13,8 +13,8 @@
  * limitations under the License.
  */
 
-#ifndef PLAYER_IMPL_H
-#define PLAYER_IMPL_H
+#ifndef PLAYER_IMPL_HP
+#define PLAYER_IMPL_HP
 
 #include "player.h"
 #include "nocopyable.h"
@@ -66,6 +66,8 @@ public:
     int32_t GetCurrentTrack(int32_t trackType, int32_t &index) override;
     int32_t SetDecryptConfig(const sptr<DrmStandard::IMediaKeySessionService> &keySessionProxy,
         bool svp) override;
+    int32_t SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+        u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) override;
     int32_t Init();
 private:
     std::shared_ptr<IPlayerService> playerService_ = nullptr;
diff --git a/interfaces/inner_api/native/player.h b/interfaces/inner_api/native/player.h
index 99ba49e699255efb326e8e044781589f2c8060eb..c99e3dd00b83a2f55c5766a39fc0d8c3454a8df9 100644
--- a/interfaces/inner_api/native/player.h
+++ b/interfaces/inner_api/native/player.h
@@ -385,6 +385,9 @@ public:
      */
     virtual int32_t SetVolume(float leftVolume, float rightVolume) = 0;
 
+    virtual int32_t SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+        u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) = 0;
+
     /**
      * @brief Changes the playback position.
      *
diff --git a/interfaces/kits/js/BUILD.gn b/interfaces/kits/js/BUILD.gn
index c5dd71597cd392da455ef9131ae2536d3f1bdd61..d38bbadfd2c20924bb0ed91d2b6f96c75c6f8a95 100644
--- a/interfaces/kits/js/BUILD.gn
+++ b/interfaces/kits/js/BUILD.gn
@@ -54,6 +54,7 @@ ohos_shared_library("media") {
     "//foundation/multimedia/player_framework/frameworks/js/player",
     "//foundation/multimedia/player_framework/frameworks/js/recorder",
     "//foundation/multimedia/player_framework/frameworks/js/media",
+    "//foundation/multimedia/player_framework/frameworks/js/mediasource",
     "//foundation/multimedia/player_framework/frameworks/js/common",
     "${multimedia_player_framework_path}/frameworks/js/avscreen_capture",
     "//foundation/multimedia/player_framework/services/utils/include",
@@ -69,6 +70,7 @@ ohos_shared_library("media") {
     "//foundation/multimedia/player_framework/frameworks/js/common/common_napi.cpp",
     "//foundation/multimedia/player_framework/frameworks/js/media/media_enum_napi.cpp",
     "//foundation/multimedia/player_framework/frameworks/js/media/native_module_ohos_media.cpp",
+    "//foundation/multimedia/player_framework/frameworks/js/mediasource/media_source_napi.cpp"
   ]
 
   if (multimedia_player_framework_support_player) {
diff --git a/services/engine/gstreamer/player/player_engine_gst_impl.cpp b/services/engine/gstreamer/player/player_engine_gst_impl.cpp
index 9d401d4cfa3edd4279a6ddf32df0a0d3a9f325e5..67fe0e7f812663a49c4d71d1abd310165d604189 100644
--- a/services/engine/gstreamer/player/player_engine_gst_impl.cpp
+++ b/services/engine/gstreamer/player/player_engine_gst_impl.cpp
@@ -905,6 +905,22 @@ int32_t PlayerEngineGstImpl::SetVolume(float leftVolume, float rightVolume)
     return MSERR_OK;
 }
 
+int32_t PlayerEngineGstImpl::SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+    u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR)
+{
+    std::unique_lock<std::mutex> lock(mutex_);
+    if (playBinCtrler_ != nullptr) {
+        for (const auto& pair : header) {
+            MEDIA_LOGD("header info %s", pair.first.c_str());
+        }
+        MEDIA_LOGD("SetMediaSource preferedWidth %d preferedHeight %d bufferDuration %d preferHDR %d", preferedWidth, 
+        preferedHeight, bufferDuration, preferHDR);
+        //playBinCtrler_->SetDurationSize(durationSize);
+    }
+    return MSERR_OK;
+
+}
+
 int32_t PlayerEngineGstImpl::SelectBitRate(uint32_t bitRate)
 {
     std::unique_lock<std::mutex> lock(mutex_);
diff --git a/services/engine/gstreamer/player/player_engine_gst_impl.h b/services/engine/gstreamer/player/player_engine_gst_impl.h
index a5ad408735abdd2d4f8aa131b688e640bba4db8d..df168ee3325daf2b248c4969ee6d02301586f33b 100644
--- a/services/engine/gstreamer/player/player_engine_gst_impl.h
+++ b/services/engine/gstreamer/player/player_engine_gst_impl.h
@@ -57,6 +57,8 @@ public:
     int32_t GetVideoTrackInfo(std::vector<Format> &videoTrack) override;
     int32_t GetDuration(int32_t &duration) override;
     int32_t SetPlaybackSpeed(PlaybackRateMode mode) override;
+    int32_t SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+        u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) override;
     int32_t SetParameter(const Format &param) override;
     int32_t GetVideoHeight() override;
     int32_t SetLooping(bool loop) override;
diff --git a/services/engine/histreamer/player/hiplayer_impl.cpp b/services/engine/histreamer/player/hiplayer_impl.cpp
index a602aed445940115d5094ac8046114fe52d32bd4..282aa9059f0493045ec760c425f4f989740c5bfa 100755
--- a/services/engine/histreamer/player/hiplayer_impl.cpp
+++ b/services/engine/histreamer/player/hiplayer_impl.cpp
@@ -186,6 +186,17 @@ int32_t HiPlayerImpl::SetSource(const std::string& uri)
     return TransStatus(Status::OK);
 }
 
+int32_t HiPlayerImpl::SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+    u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR)
+{
+    this->header = header;
+    this->preferedWidth = preferedWidth;
+    this->preferedHeight = preferedHeight;
+    this->bufferDuration = bufferDuration;
+    this->preferHDR = preferHDR;
+    return MSERR_OK;
+}
+
 int32_t HiPlayerImpl::SetSource(const std::shared_ptr<IMediaDataSource>& dataSrc)
 {
     MediaTrace trace("HiPlayerImpl::SetSource dataSrc");
diff --git a/services/engine/histreamer/player/hiplayer_impl.h b/services/engine/histreamer/player/hiplayer_impl.h
index 972fe1232e77527ea59241f0a4ee746b844d1c6d..c92717d1923fbc75529df0c73df0256cd77842a0 100755
--- a/services/engine/histreamer/player/hiplayer_impl.h
+++ b/services/engine/histreamer/player/hiplayer_impl.h
@@ -66,6 +66,8 @@ public:
     int32_t GetCurrentTime(int32_t& currentPositionMs) override;
     int32_t GetDuration(int32_t& durationMs) override;
     int32_t SetPlaybackSpeed(PlaybackRateMode mode) override;
+    int32_t SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+        u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) override;
     int32_t GetPlaybackSpeed(PlaybackRateMode& mode) override;
     int32_t SelectBitRate(uint32_t bitRate) override;
     int32_t GetAudioEffectMode(int32_t &effectMode) override;
@@ -194,6 +196,11 @@ private:
 
     int32_t rotation90 = 90;
     int32_t rotation270 = 270;
+    std::map<std::string, std::string> header;
+    u_int32_t preferedWidth = 0;
+    u_int32_t preferedHeight = 0;
+    u_int32_t bufferDuration = 0;
+    bool preferHDR = false;
 };
 } // namespace Media
 } // namespace OHOS
diff --git a/services/include/i_player_service.h b/services/include/i_player_service.h
index 13ace880b889d2b9b478ea5bcc8aa2e784915460..39e3eee731001b22f6246537e49cc939f6cb3e4d 100644
--- a/services/include/i_player_service.h
+++ b/services/include/i_player_service.h
@@ -277,6 +277,8 @@ public:
      */
     virtual int32_t SetPlaybackSpeed(PlaybackRateMode mode) = 0;
 
+    virtual int32_t SetMediaSource(std::map<std::string, std::string> header, uint32_t preferedWidth, 
+        uint32_t preferedHeight, uint32_t bufferDuration, bool preferHDR) = 0;
     /**
      * @brief set the bit rate use for hls player
      *
diff --git a/services/services/engine_intf/i_player_engine.h b/services/services/engine_intf/i_player_engine.h
index 6ee15f862681250652effb604532a99f9cb6c3df..565074c009508a98279ffb6e8f090032bd81e85a 100644
--- a/services/services/engine_intf/i_player_engine.h
+++ b/services/services/engine_intf/i_player_engine.h
@@ -78,6 +78,8 @@ public:
     virtual int32_t GetDuration(int32_t &duration) = 0;
     virtual int32_t SetPlaybackSpeed(PlaybackRateMode mode) = 0;
     virtual int32_t GetPlaybackSpeed(PlaybackRateMode &mode) = 0;
+    virtual int32_t SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+        u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) = 0;
     virtual int32_t SetVideoSurface(sptr<Surface> surface) = 0;
 
     virtual int32_t SetDecryptConfig(const sptr<OHOS::DrmStandard::IMediaKeySessionService> &keySessionProxy,
diff --git a/services/services/player/client/player_client.cpp b/services/services/player/client/player_client.cpp
index 7d81ff272d6db9424ebfdd846aa7f9a3039e857e..087dfc25a747b992525c7b3d73d74d470b266adc 100644
--- a/services/services/player/client/player_client.cpp
+++ b/services/services/player/client/player_client.cpp
@@ -258,6 +258,14 @@ int32_t PlayerClient::SetPlaybackSpeed(PlaybackRateMode mode)
     return playerProxy_->SetPlaybackSpeed(mode);
 }
 
+int32_t PlayerClient::SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+    u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    CHECK_AND_RETURN_RET_LOG(playerProxy_ != nullptr, MSERR_SERVICE_DIED, "player service does not exist..");
+    return playerProxy_->SetMediaSource(header, preferedWidth, preferedHeight, bufferDuration, preferHDR);
+}
+
 int32_t PlayerClient::GetPlaybackSpeed(PlaybackRateMode &mode)
 {
     std::lock_guard<std::mutex> lock(mutex_);
diff --git a/services/services/player/client/player_client.h b/services/services/player/client/player_client.h
index efee98aaac07d37943235b9a9bcbc798d764bef5..30fb83ef87f81dfe2c1c255af3ddc0fe93ad4bba 100644
--- a/services/services/player/client/player_client.h
+++ b/services/services/player/client/player_client.h
@@ -52,6 +52,8 @@ public:
     int32_t GetAudioTrackInfo(std::vector<Format> &audioTrack) override;
     int32_t GetVideoHeight() override;
     int32_t SetPlaybackSpeed(PlaybackRateMode mode) override;
+    int32_t SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+        u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) override;
     int32_t GetDuration(int32_t &duration) override;
     int32_t GetVideoTrackInfo(std::vector<Format> &videoTrack) override;
     int32_t GetVideoWidth() override;
diff --git a/services/services/player/ipc/i_standard_player_service.h b/services/services/player/ipc/i_standard_player_service.h
index ec760f8781b5832ede6262ae74e546753dfe0555..b43fa14672e78f0b57e71cfe07782acdf34d1cf4 100644
--- a/services/services/player/ipc/i_standard_player_service.h
+++ b/services/services/player/ipc/i_standard_player_service.h
@@ -55,6 +55,8 @@ public:
     virtual int32_t GetDuration(int32_t &duration) = 0;
     virtual int32_t SetPlaybackSpeed(PlaybackRateMode mode) = 0;
     virtual int32_t GetPlaybackSpeed(PlaybackRateMode &mode) = 0;
+    virtual int32_t SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+        u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) = 0;
 #ifdef SUPPORT_VIDEO
     virtual int32_t SetVideoSurface(sptr<Surface> surface) = 0;
 #endif
@@ -99,6 +101,7 @@ public:
         GET_DURATION,
         SET_PLAYERBACK_SPEED,
         GET_PLAYERBACK_SPEED,
+        SET_MEDIA_SOURCE,
         SET_VIDEO_SURFACE,
         IS_PLAYING,
         IS_LOOPING,
diff --git a/services/services/player/ipc/player_service_proxy.cpp b/services/services/player/ipc/player_service_proxy.cpp
index 4c2e124c6ed70b6ff67c6bb72cd1eb8510383adb..ac87f0ce33b087fd1e3d4dd3cde48ecae155dbb1 100644
--- a/services/services/player/ipc/player_service_proxy.cpp
+++ b/services/services/player/ipc/player_service_proxy.cpp
@@ -70,6 +70,7 @@ PlayerServiceProxy::PlayerServiceProxy(const sptr<IRemoteObject> &impl)
     playerFuncs_[DESELECT_TRACK] = "Player::DeslectTrack";
     playerFuncs_[GET_CURRENT_TRACK] = "Player::GetCurrentTrack";
     playerFuncs_[SET_DECRYPT_CONFIG] = "Player::SetDecryptConfig";
+    playerFuncs_[SET_MEDIA_SOURCE] = "Player::SetMediaSource";
 }
 
 PlayerServiceProxy::~PlayerServiceProxy()
@@ -516,6 +517,42 @@ int32_t PlayerServiceProxy::SetPlaybackSpeed(PlaybackRateMode mode)
     return reply.ReadInt32();
 }
 
+int32_t PlayerServiceProxy::SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+    u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR)
+{
+    MediaTrace trace("binder::SetDurationSize");
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+
+    bool token = data.WriteInterfaceToken(PlayerServiceProxy::GetDescriptor());
+    CHECK_AND_RETURN_RET_LOG(token, MSERR_INVALID_OPERATION, "Failed to write descriptor!");
+    auto headerSize = static_cast<uint32_t>(header.size());
+    if (!data.WriteUint32(headerSize)) {
+        MEDIA_LOGI("Write mapSize failed");
+        return -1;
+    }
+    for (auto [kstr, vstr] : header) {
+        if (!data.WriteString(kstr)) {
+            MEDIA_LOGI("Write kstr failed");
+            return -1;
+        }
+        if (!data.WriteString(vstr)) {
+            MEDIA_LOGI("Write vstr failed");
+            return -1;
+        }
+    }
+    (void)data.WriteUint32(preferedWidth);
+    (void)data.WriteUint32(preferedHeight);
+    (void)data.WriteUint32(bufferDuration);
+    (void)data.WriteBool(preferHDR);
+    int32_t error = SendRequest(SET_MEDIA_SOURCE, data, reply, option);
+    CHECK_AND_RETURN_RET_LOG(error == MSERR_OK, MSERR_INVALID_OPERATION,
+        "SetMediaSource failed, error: %{public}d", error);
+    return reply.ReadInt32();
+
+}
+
 int32_t PlayerServiceProxy::GetPlaybackSpeed(PlaybackRateMode &mode)
 {
     MediaTrace trace("binder::GetPlaybackSpeed");
diff --git a/services/services/player/ipc/player_service_proxy.h b/services/services/player/ipc/player_service_proxy.h
index 6f782132189c7c5c4794d1cb727bd8395b4814c0..57fe8a4b8d706f561488624e93a4a6dea2b41122 100644
--- a/services/services/player/ipc/player_service_proxy.h
+++ b/services/services/player/ipc/player_service_proxy.h
@@ -37,6 +37,8 @@ public:
     int32_t GetAudioTrackInfo(std::vector<Format> &audioTrack) override;
     int32_t AddSubSource(const std::string &url) override;
     int32_t SetPlaybackSpeed(PlaybackRateMode mode) override;
+    int32_t SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+        u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) override;
     int32_t AddSubSource(int32_t fd, int64_t offset, int64_t size) override;
     int32_t Seek(int32_t mSeconds, PlayerSeekMode mode) override;
     int32_t Stop() override;
diff --git a/services/services/player/ipc/player_service_stub.cpp b/services/services/player/ipc/player_service_stub.cpp
index 28875e8081084b549003bead6c2b30f410a3fa4e..162a3e10a3201afd1c4ba44eae8355591567a1e3 100644
--- a/services/services/player/ipc/player_service_stub.cpp
+++ b/services/services/player/ipc/player_service_stub.cpp
@@ -91,6 +91,7 @@ void PlayerServiceStub::SetPlayerFuncs()
     playerFuncs_[GET_DURATION] = { &PlayerServiceStub::GetDuration, "Player::GetDuration" };
     playerFuncs_[SET_PLAYERBACK_SPEED] = { &PlayerServiceStub::SetPlaybackSpeed, "Player::SetPlaybackSpeed" };
     playerFuncs_[GET_PLAYERBACK_SPEED] = { &PlayerServiceStub::GetPlaybackSpeed, "Player::GetPlaybackSpeed" };
+    playerFuncs_[SET_MEDIA_SOURCE] = { &PlayerServiceStub::SetMediaSource, "Player::SetMediaSource" };
 #ifdef SUPPORT_VIDEO
     playerFuncs_[SET_VIDEO_SURFACE] = { &PlayerServiceStub::SetVideoSurface, "Player::SetVideoSurface" };
 #endif
@@ -354,6 +355,14 @@ int32_t PlayerServiceStub::SetPlaybackSpeed(PlaybackRateMode mode)
     return playerServer_->SetPlaybackSpeed(mode);
 }
 
+int32_t PlayerServiceStub::SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+    u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR)
+{
+    MediaTrace trace("binder::SetDuration");
+    CHECK_AND_RETURN_RET_LOG(playerServer_ != nullptr, MSERR_NO_MEMORY, "player server is nullptr");
+    return playerServer_->SetMediaSource(header, preferedWidth, preferedHeight, bufferDuration, preferHDR);
+}
+
 int32_t PlayerServiceStub::GetPlaybackSpeed(PlaybackRateMode &mode)
 {
     MediaTrace trace("binder::GetPlaybackSpeed");
@@ -699,6 +708,23 @@ int32_t PlayerServiceStub::SetPlaybackSpeed(MessageParcel &data, MessageParcel &
     return MSERR_OK;
 }
 
+int32_t PlayerServiceStub::SetMediaSource(MessageParcel &data, MessageParcel &reply)
+{   
+    auto mapSize = data.ReadUint32();
+    std::map<std::string, std::string> headerMap;
+    while (mapSize--) {
+        auto kstr = data.ReadString();
+        auto vstr = data.ReadString();
+        headerMap.emplace(kstr, vstr);
+    }
+    u_int32_t preferedWidth = data.ReadUint32();
+    u_int32_t preferedHeight = data.ReadUint32();
+    u_int32_t bufferDuration = data.ReadUint32();
+    bool preferHDR = data.ReadBool();
+    reply.WriteInt32(SetMediaSource(headerMap, preferedWidth, preferedHeight, bufferDuration, preferHDR));
+    return MSERR_OK;
+}
+
 int32_t PlayerServiceStub::GetPlaybackSpeed(MessageParcel &data, MessageParcel &reply)
 {
     (void)data;
diff --git a/services/services/player/ipc/player_service_stub.h b/services/services/player/ipc/player_service_stub.h
index 2cff901ff4a7370796ab9adaa17c038f38e7f035..1bd65e2c1a86a0bfbd4fa750a50bff1facaf512d 100644
--- a/services/services/player/ipc/player_service_stub.h
+++ b/services/services/player/ipc/player_service_stub.h
@@ -72,6 +72,8 @@ public:
     int32_t DumpInfo(int32_t fd);
     int32_t DeselectTrack(int32_t index) override;
     int32_t GetCurrentTrack(int32_t trackType, int32_t &index) override;
+    int32_t SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+        u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) override;
     bool IsPlaying() override;
     bool IsLooping() override;
     int32_t SetDecryptConfig(const sptr<DrmStandard::IMediaKeySessionService> &keySessionProxy,
@@ -129,6 +131,7 @@ private:
     int32_t DeselectTrack(MessageParcel &data, MessageParcel &reply);
     int32_t GetCurrentTrack(MessageParcel &data, MessageParcel &reply);
     int32_t SetDecryptConfig(MessageParcel &data, MessageParcel &reply);
+    int32_t SetMediaSource(MessageParcel &data, MessageParcel &reply);
     using PlayerStubFunc = int32_t(PlayerServiceStub::*)(MessageParcel &data, MessageParcel &reply);
     std::map<uint32_t, std::pair<PlayerStubFunc, std::string>> playerFuncs_;
 };
diff --git a/services/services/player/server/player_server.cpp b/services/services/player/server/player_server.cpp
index ee8c3c8622507f71a8378dd4507432d50554ab96..2a07d64c6c16d7e8b5cb933cd5fd83f83910ba5e 100755
--- a/services/services/player/server/player_server.cpp
+++ b/services/services/player/server/player_server.cpp
@@ -912,6 +912,13 @@ int32_t PlayerServer::HandleSetPlaybackSpeed(PlaybackRateMode mode)
     return MSERR_OK;
 }
 
+int32_t PlayerServer::SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+    u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) 
+{
+    (void)playerEngine_->SetMediaSource(header, preferedWidth, preferedHeight, bufferDuration, preferHDR);
+    return MSERR_OK;
+}
+
 void PlayerServer::HandleEos()
 {
     if (config_.looping.load()) {
diff --git a/services/services/player/server/player_server.h b/services/services/player/server/player_server.h
index fe997ffd66705f6650b30f0987407a0d9d5ff992..b270a309368f0fafbe9b0e866aaf4bdbcbe4fa3e 100644
--- a/services/services/player/server/player_server.h
+++ b/services/services/player/server/player_server.h
@@ -96,6 +96,8 @@ public:
     int32_t AddSubSource(const std::string &url) override;
     int32_t AddSubSource(int32_t fd, int64_t offset, int64_t size) override;
     int32_t GetPlaybackSpeed(PlaybackRateMode &mode) override;
+    int32_t SetMediaSource(std::map<std::string, std::string> header, u_int32_t preferedWidth, 
+        u_int32_t preferedHeight, u_int32_t bufferDuration, bool preferHDR) override;
 #ifdef SUPPORT_VIDEO
     int32_t SetVideoSurface(sptr<Surface> surface) override;
 #endif
