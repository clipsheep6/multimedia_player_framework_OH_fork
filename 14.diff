diff --git a/bundle.json b/bundle.json
index 8efb4f0697fdb164803cceaf803f4e2a258b2eb6..e64e8fc95a24b4a31ef4b9304a12c401203903ef 100644
--- a/bundle.json
+++ b/bundle.json
@@ -72,7 +72,8 @@
               "header_files": [
                   "player.h",
                   "recorder.h",
-                  "avcodec_list.h"
+                  "avcodec_list.h",
+                  "recorder_profiles.h"
               ],
               "header_base": "//foundation/multimedia/media_standard/interfaces/inner_api/native"
             }
diff --git a/frameworks/js/avcodec/utils/avcodec_napi_utils.h b/frameworks/js/avcodec/utils/avcodec_napi_utils.h
index da095086d7dd014ca3f14f97a315ed2d86e7a654..e6696d60e1af57daf54147322b176567d7e39372 100644
--- a/frameworks/js/avcodec/utils/avcodec_napi_utils.h
+++ b/frameworks/js/avcodec/utils/avcodec_napi_utils.h
@@ -21,6 +21,7 @@
 #include "format.h"
 #include "napi/native_api.h"
 #include "napi/native_node_api.h"
+#include "recorder_profiles.h"
 
 namespace OHOS {
 namespace Media {
diff --git a/frameworks/js/common/common_napi.cpp b/frameworks/js/common/common_napi.cpp
index afe0aad68552a8350813658eb7fddbd4bf7424b2..f8ba66b70fd39daaeedfdfefdd6529af01306690 100644
--- a/frameworks/js/common/common_napi.cpp
+++ b/frameworks/js/common/common_napi.cpp
@@ -629,5 +629,24 @@ void MediaAsyncContext::CheckCtorResult(napi_env env, napi_value &result, MediaA
         }
     }
 }
+
+bool CommonNapi::AddStringProperty(napi_env env, napi_value obj, const std::string &key, std::string value)
+{
+    CHECK_AND_RETURN_RET(obj != nullptr, false);
+
+    napi_value keyNapi = nullptr;
+    napi_status status = napi_create_string_utf8(env, key.c_str(), NAPI_AUTO_LENGTH, &keyNapi);
+    CHECK_AND_RETURN_RET(status == napi_ok, false);
+
+    napi_value valueNapi = nullptr;
+    status = napi_create_string_utf8(env, value.c_str(), NAPI_AUTO_LENGTH, &valueNapi);
+    CHECK_AND_RETURN_RET(status == napi_ok, false);
+
+    status = napi_set_property(env, obj, keyNapi, valueNapi);
+    CHECK_AND_RETURN_RET_LOG(status == napi_ok, false, "Failed to set property");
+
+    return true;
+}
+
 } // namespace Media
 } // namespace OHOS
diff --git a/frameworks/js/common/common_napi.h b/frameworks/js/common/common_napi.h
index a251964ed72f031fc86401269001219ec40b8eac..2249718ce7d2612d72b3f2742f0ae222b869c4f5 100644
--- a/frameworks/js/common/common_napi.h
+++ b/frameworks/js/common/common_napi.h
@@ -54,6 +54,7 @@ public:
     static bool AddNumberPropInt32(napi_env env, napi_value obj, const std::string &key, int32_t value);
     static bool AddNumberPropInt64(napi_env env, napi_value obj, const std::string &key, int64_t value);
     static bool AddArrayInt(napi_env env, napi_value &array, const std::vector<int32_t> &vec);
+	static bool AddStringProperty(napi_env env, napi_value obj, const std::string &key, std::string value);
 };
 
 class MediaJsResult {
@@ -62,6 +63,21 @@ public:
     virtual napi_status GetJsResult(napi_env env, napi_value &result) = 0;
 };
 
+class MediaJsResultBoolean : public MediaJsResult {
+public:
+    explicit MediaJsResultBoolean(bool value)
+        : value_(value)
+    {
+    }
+    ~MediaJsResultBoolean() = default;
+    napi_status GetJsResult(napi_env env, napi_value &result) override
+    {
+        return napi_get_boolean(env, value_, &result);
+    }
+private:
+    bool value_;
+};
+
 class MediaJsResultInt : public MediaJsResult {
 public:
     explicit MediaJsResultInt(int32_t value)
diff --git a/frameworks/js/common/media_enum_napi.cpp b/frameworks/js/common/media_enum_napi.cpp
index e7c31f964b6526dbe9b9dda2738d483723b3c765..e7b313940d58d877c7df2932f8b180139e535a44 100644
--- a/frameworks/js/common/media_enum_napi.cpp
+++ b/frameworks/js/common/media_enum_napi.cpp
@@ -23,6 +23,8 @@
 #include "recorder.h"
 #include "avcodec_info.h"
 #include "avcodec_common.h"
+#include "recorder_profiles.h"
+#include "avcontainer_common.h"
 
 namespace {
     constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "MediaEnumNapi"};
@@ -96,9 +98,29 @@ static const std::vector<struct JsEnumInt> g_mediaType = {
 };
 
 static const std::vector<struct JsEnumInt> g_videoRecorderQualityLevel = {
-    { "RECORDER_QUALITY_LOW", MediaType::MEDIA_TYPE_AUD },
-    { "RECORDER_QUALITY_HIGH", MediaType::MEDIA_TYPE_VID },
-    { "MEDIA_TYPE_SUBTITLE", MediaType::MEDIA_TYPE_SUBTITLE },
+    { "RECORDER_QUALITY_LOW", VideoRecorderQualityLevel::RECORDER_QUALITY_LOW },
+    { "RECORDER_QUALITY_HIGH", VideoRecorderQualityLevel::RECORDER_QUALITY_HIGH },
+    { "RECORDER_QUALITY_QCIF", VideoRecorderQualityLevel::RECORDER_QUALITY_QCIF },
+    { "RECORDER_QUALITY_CIF", VideoRecorderQualityLevel::RECORDER_QUALITY_CIF },
+    { "RECORDER_QUALITY_480P", VideoRecorderQualityLevel::RECORDER_QUALITY_480P },
+    { "RECORDER_QUALITY_720P", VideoRecorderQualityLevel::RECORDER_QUALITY_720P },
+    { "RECORDER_QUALITY_1080P", VideoRecorderQualityLevel::RECORDER_QUALITY_1080P },
+    { "RECORDER_QUALITY_QVGA", VideoRecorderQualityLevel::RECORDER_QUALITY_QVGA },
+    { "RECORDER_QUALITY_2160P", VideoRecorderQualityLevel::RECORDER_QUALITY_2160P },
+    { "RECORDER_QUALITY_TIME_LAPSE_LOW", VideoRecorderQualityLevel::RECORDER_QUALITY_TIME_LAPSE_LOW },
+    { "RECORDER_QUALITY_TIME_LAPSE_HIGH", VideoRecorderQualityLevel::RECORDER_QUALITY_TIME_LAPSE_HIGH },
+    { "RECORDER_QUALITY_TIME_LAPSE_QCIF", VideoRecorderQualityLevel::RECORDER_QUALITY_TIME_LAPSE_QCIF },
+    { "RECORDER_QUALITY_TIME_LAPSE_CIF", VideoRecorderQualityLevel::RECORDER_QUALITY_TIME_LAPSE_CIF },
+    { "RECORDER_QUALITY_TIME_LAPSE_480P", VideoRecorderQualityLevel::RECORDER_QUALITY_TIME_LAPSE_480P },
+    { "RECORDER_QUALITY_TIME_LAPSE_720P", VideoRecorderQualityLevel::RECORDER_QUALITY_TIME_LAPSE_720P },
+    { "RECORDER_QUALITY_TIME_LAPSE_1080P", VideoRecorderQualityLevel::RECORDER_QUALITY_TIME_LAPSE_1080P },
+    { "RECORDER_QUALITY_TIME_LAPSE_QVGA", VideoRecorderQualityLevel::RECORDER_QUALITY_TIME_LAPSE_QVGA },
+    { "RECORDER_QUALITY_TIME_LAPSE_2160P", VideoRecorderQualityLevel::RECORDER_QUALITY_TIME_LAPSE_2160P },
+    { "RECORDER_QUALITY_HIGH_SPEED_LOW", VideoRecorderQualityLevel::RECORDER_QUALITY_HIGH_SPEED_LOW },
+    { "RECORDER_QUALITY_HIGH_SPEED_HIGH", VideoRecorderQualityLevel::RECORDER_QUALITY_HIGH_SPEED_HIGH },
+    { "RECORDER_QUALITY_HIGH_SPEED_480P", VideoRecorderQualityLevel::RECORDER_QUALITY_HIGH_SPEED_480P },
+    { "RECORDER_QUALITY_HIGH_SPEED_720P", VideoRecorderQualityLevel::RECORDER_QUALITY_HIGH_SPEED_720P },
+    { "RECORDER_QUALITY_HIGH_SPEED_1080P", VideoRecorderQualityLevel::RECORDER_QUALITY_HIGH_SPEED_1080P },
 };
 
 static const std::vector<struct JsEnumInt> g_audioSourceType = {
@@ -218,8 +240,15 @@ static const std::vector<struct JsEnumInt> g_VP8Profile = {
 };
 
 static const std::vector<struct JsEnumString> g_containerFormatType = {
-    { "CFT_MPEG_4", "mp4" },
-    { "CFT_MPEG_4A", "m4a" },
+    { "CFT_MPEG_4", ContainerFormatType::CFT_MPEG_4 },
+    { "CFT_MPEG_TS", ContainerFormatType::CFT_MPEG_TS },
+    { "CFT_MKV", ContainerFormatType::CFT_MKV },
+    { "CFT_WEBM", ContainerFormatType::CFT_WEBM },
+    { "CFT_MPEG_4A", ContainerFormatType::CFT_MPEG_4A },
+    { "CFT_OGG", ContainerFormatType::CFT_OGG },
+    { "CFT_WAV", ContainerFormatType::CFT_WAV },
+    { "CFT_AAC", ContainerFormatType::CFT_AAC },
+    { "CFT_FLAC", ContainerFormatType::CFT_FLAC },
 };
 
 static const std::vector<struct JsEnumString> g_codecMimeType = {
@@ -279,6 +308,7 @@ static const std::map<std::string_view, const std::vector<struct JsEnumInt>&> g_
     { "AudioOutputFormat", g_recorderAudioOutputFormat },
     { "PlaybackSpeed", g_playbackSpeed },
     { "MediaType", g_mediaType },
+    { "VideoRecorderQualityLevel", g_videoRecorderQualityLevel },
     { "AudioSourceType", g_audioSourceType },
     { "VideoSourceType", g_videoSourceType },
     { "FrameFlags", g_frameFlags },
diff --git a/frameworks/js/mediacapability/media_capability_napi.cpp b/frameworks/js/mediacapability/media_capability_napi.cpp
index 3cb699789bb0aee24af11e8c354f2d4e2fcbae7a..9faa189f438ee72c54c93b59dd771f0e4c593630 100644
--- a/frameworks/js/mediacapability/media_capability_napi.cpp
+++ b/frameworks/js/mediacapability/media_capability_napi.cpp
@@ -21,6 +21,7 @@
 #include "media_log.h"
 #include "media_errors.h"
 #include "common_napi.h"
+#include "recorder_profiles.h"
 
 namespace {
     constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "MediaCapsNapi"};
@@ -55,6 +56,11 @@ napi_value MediaCapsNapi::Init(napi_env env, napi_value exports)
         DECLARE_NAPI_FUNCTION("findVideoDecoder", FindVideoDecoder),
         DECLARE_NAPI_FUNCTION("getVideoEncoderCaps", GetVideoEncoderCaps),
         DECLARE_NAPI_FUNCTION("findVideoEncoder", FindVideoEncoder),
+        DECLARE_NAPI_FUNCTION("getAudioRecorderCaps", GetAudioRecorderCaps),
+        DECLARE_NAPI_FUNCTION("isAudioRecoderConfigSupported", IsAudioRecoderConfigSupported),
+        DECLARE_NAPI_FUNCTION("getVideoRecorderCaps", GetVideoRecorderCaps),
+        DECLARE_NAPI_FUNCTION("getVideoRecorderProfile", GetVideoRecorderProfile),
+        DECLARE_NAPI_FUNCTION("hasVideoRecorderProfile", HasVideoRecorderProfile),
         DECLARE_NAPI_FUNCTION("getAVMuxerFormatList", GetAVMuxerFormatList),
     };
     napi_property_descriptor staticProperty[] = {
@@ -535,6 +541,250 @@ napi_value MediaCapsNapi::FindVideoEncoder(napi_env env, napi_callback_info info
     return result;
 }
 
+napi_value MediaCapsNapi::GetAudioRecorderCaps(napi_env env, napi_callback_info info)
+{
+    napi_value result = nullptr;
+    napi_get_undefined(env, &result);
+
+    auto asyncCtx = std::make_unique<MediaCapsAsyncContext>(env);
+
+    napi_value jsThis = nullptr;
+    napi_value args[1] = {nullptr};
+    size_t argCount = 1;
+    napi_status status = napi_get_cb_info(env, info, &argCount, args, &jsThis, nullptr);
+    if (status != napi_ok || jsThis == nullptr) {
+        asyncCtx->SignError(MSERR_EXT_INVALID_VAL, "Failed to napi_get_cb_info");
+    }
+
+    asyncCtx->callbackRef = CommonNapi::CreateReference(env, args[0]);
+    asyncCtx->deferred = CommonNapi::CreatePromise(env, asyncCtx->callbackRef, result);
+
+    (void)napi_unwrap(env, jsThis, reinterpret_cast<void **>(&asyncCtx->napi));
+
+    napi_value resource = nullptr;
+    
+    napi_create_string_utf8(env, "GetAudioRecorderCaps", NAPI_AUTO_LENGTH, &resource);
+    NAPI_CALL(env, napi_create_async_work(env, nullptr, resource,
+        [](napi_env env, void* data) {
+            auto asyncCtx = reinterpret_cast<MediaCapsAsyncContext *>(data);
+            if (asyncCtx == nullptr) {
+                MEDIA_LOGE("Failed, asyncCtx is nullptr");
+                return;
+            } else if (asyncCtx->napi == nullptr) {
+                asyncCtx->SignError(MSERR_EXT_UNKNOWN, "nullptr");
+                return;
+            }
+            auto audioRecorderCaps = RecorderProfilesFactory::CreateRecorderProfiles().GetAudioRecorderCaps();
+            asyncCtx->JsResult = std::make_unique<MediaJsAudioRecorderCapsArray>(audioRecorderCaps);
+        },
+        MediaAsyncContext::CompleteCallback, static_cast<void *>(asyncCtx.get()), &asyncCtx->work));
+
+    NAPI_CALL(env, napi_queue_async_work(env, asyncCtx->work));
+    asyncCtx.release();
+
+    return result;
+}
+
+napi_value MediaCapsNapi::IsAudioRecoderConfigSupported(napi_env env, napi_callback_info info)
+{
+    napi_value result = nullptr;
+    napi_get_undefined(env, &result);
+
+    auto asyncCtx = std::make_unique<MediaCapsAsyncContext>(env);
+
+    napi_value jsThis = nullptr;
+    napi_value args[2] = {nullptr};
+    size_t argCount = 2;
+    napi_status status = napi_get_cb_info(env, info, &argCount, args, &jsThis, nullptr);
+    if (status != napi_ok || jsThis == nullptr) {
+        asyncCtx->SignError(MSERR_EXT_INVALID_VAL, "Failed to napi_get_cb_info");
+    }
+
+    napi_valuetype valueType = napi_undefined;
+    if (args[0] != nullptr && napi_typeof(env, args[0], &valueType) == napi_ok && valueType == napi_object) {
+        (void)MediaCapabilityUtil::ExtractAudioRecorderProfile(env, args[0], asyncCtx->profile);
+    } else {
+        asyncCtx->SignError(MSERR_EXT_INVALID_VAL, "Illegal argument");
+    }
+
+    asyncCtx->callbackRef = CommonNapi::CreateReference(env, args[1]);
+    asyncCtx->deferred = CommonNapi::CreatePromise(env, asyncCtx->callbackRef, result);
+
+    (void)napi_unwrap(env, jsThis, reinterpret_cast<void **>(&asyncCtx->napi));
+
+    napi_value resource = nullptr;
+    napi_create_string_utf8(env, "IsAudioRecoderConfigSupported", NAPI_AUTO_LENGTH, &resource);
+    NAPI_CALL(env, napi_create_async_work(env, nullptr, resource,
+        [](napi_env env, void* data) {
+            auto asyncCtx = reinterpret_cast<MediaCapsAsyncContext *>(data);
+            if (asyncCtx == nullptr) {
+                MEDIA_LOGE("Failed, asyncCtx is nullptr");
+                return;
+            } else if (asyncCtx->napi == nullptr) {
+                asyncCtx->SignError(MSERR_EXT_UNKNOWN, "nullptr");
+                return;
+            }
+            bool outResult = RecorderProfilesFactory::CreateRecorderProfiles().IsAudioRecoderConfigSupported(
+                asyncCtx->profile);
+            asyncCtx->JsResult = std::make_unique<MediaJsResultBoolean>(outResult);
+        },
+        MediaAsyncContext::CompleteCallback, static_cast<void *>(asyncCtx.get()), &asyncCtx->work));
+
+    NAPI_CALL(env, napi_queue_async_work(env, asyncCtx->work));
+    asyncCtx.release();
+
+    return result;
+}
+
+napi_value MediaCapsNapi::GetVideoRecorderCaps(napi_env env, napi_callback_info info)
+{
+    napi_value result = nullptr;
+    napi_get_undefined(env, &result);
+
+    auto asyncCtx = std::make_unique<MediaCapsAsyncContext>(env);
+
+    napi_value jsThis = nullptr;
+    napi_value args[1] = {nullptr};
+    size_t argCount = 1;
+    napi_status status = napi_get_cb_info(env, info, &argCount, args, &jsThis, nullptr);
+    if (status != napi_ok || jsThis == nullptr) {
+        asyncCtx->SignError(MSERR_EXT_INVALID_VAL, "Failed to napi_get_cb_info");
+    }
+
+    asyncCtx->callbackRef = CommonNapi::CreateReference(env, args[0]);
+    asyncCtx->deferred = CommonNapi::CreatePromise(env, asyncCtx->callbackRef, result);
+
+    (void)napi_unwrap(env, jsThis, reinterpret_cast<void **>(&asyncCtx->napi));
+
+    napi_value resource = nullptr;
+    napi_create_string_utf8(env, "GetVideoRecorderCaps", NAPI_AUTO_LENGTH, &resource);
+    NAPI_CALL(env, napi_create_async_work(env, nullptr, resource,
+        [](napi_env env, void* data) {
+            auto asyncCtx = reinterpret_cast<MediaCapsAsyncContext *>(data);
+            if (asyncCtx == nullptr) {
+                MEDIA_LOGE("Failed, asyncCtx is nullptr");
+                return;
+            } else if (asyncCtx->napi == nullptr) {
+                asyncCtx->SignError(MSERR_EXT_UNKNOWN, "nullptr");
+                return;
+            }
+            auto videoRecorderCaps = RecorderProfilesFactory::CreateRecorderProfiles().GetVideoRecorderCaps();
+            asyncCtx->JsResult = std::make_unique<MediaJsVideoRecorderCapsArray>(videoRecorderCaps);
+        },
+        MediaAsyncContext::CompleteCallback, static_cast<void *>(asyncCtx.get()), &asyncCtx->work));
+
+    NAPI_CALL(env, napi_queue_async_work(env, asyncCtx->work));
+    asyncCtx.release();
+
+    return result;
+}
+
+napi_value MediaCapsNapi::GetVideoRecorderProfile(napi_env env, napi_callback_info info)
+{
+    napi_value result = nullptr;
+    napi_get_undefined(env, &result);
+
+    auto asyncCtx = std::make_unique<MediaCapsAsyncContext>(env);
+
+    napi_value jsThis = nullptr;
+    napi_value args[3] = {nullptr};
+    size_t argCount = 3;
+    napi_status status = napi_get_cb_info(env, info, &argCount, args, &jsThis, nullptr);
+    if (status != napi_ok || jsThis == nullptr) {
+        asyncCtx->SignError(MSERR_EXT_INVALID_VAL, "Failed to napi_get_cb_info");
+    }
+
+    napi_valuetype valueType = napi_undefined;
+    if ((args[0] != nullptr && napi_typeof(env, args[0], &valueType) == napi_ok && valueType == napi_number) &&
+        (args[1] != nullptr && napi_typeof(env, args[1], &valueType) == napi_ok && valueType == napi_number)) {
+        NAPI_CALL(env, napi_get_value_int32(env, args[0], &asyncCtx->sourceId));
+        NAPI_CALL(env, napi_get_value_int32(env, args[1], &asyncCtx->qualityLevel));
+    } else {
+        asyncCtx->SignError(MSERR_EXT_INVALID_VAL, "Illegal argument");
+    }
+
+    asyncCtx->callbackRef = CommonNapi::CreateReference(env, args[2]);
+    asyncCtx->deferred = CommonNapi::CreatePromise(env, asyncCtx->callbackRef, result);
+
+    (void)napi_unwrap(env, jsThis, reinterpret_cast<void **>(&asyncCtx->napi));
+
+    napi_value resource = nullptr;
+    napi_create_string_utf8(env, "GetVideoRecorderProfile", NAPI_AUTO_LENGTH, &resource);
+    NAPI_CALL(env, napi_create_async_work(env, nullptr, resource,
+        [](napi_env env, void* data) {
+            auto asyncCtx = reinterpret_cast<MediaCapsAsyncContext *>(data);
+            if (asyncCtx == nullptr) {
+                MEDIA_LOGE("Failed, asyncCtx is nullptr");
+                return;
+            } else if (asyncCtx->napi == nullptr) {
+                asyncCtx->SignError(MSERR_EXT_UNKNOWN, "nullptr");
+                return;
+            }
+            auto videoRecorderProfile = RecorderProfilesFactory::CreateRecorderProfiles().GetVideoRecorderProfile(
+                asyncCtx->sourceId, asyncCtx->qualityLevel);
+            asyncCtx->JsResult = std::make_unique<MediaJsVideoRecorderProfile>(videoRecorderProfile);
+        },
+        MediaAsyncContext::CompleteCallback, static_cast<void *>(asyncCtx.get()), &asyncCtx->work));
+
+    NAPI_CALL(env, napi_queue_async_work(env, asyncCtx->work));
+    asyncCtx.release();
+
+    return result;
+}
+
+napi_value MediaCapsNapi::HasVideoRecorderProfile(napi_env env, napi_callback_info info)
+{
+    napi_value result = nullptr;
+    napi_get_undefined(env, &result);
+
+    auto asyncCtx = std::make_unique<MediaCapsAsyncContext>(env);
+
+    napi_value jsThis = nullptr;
+    napi_value args[3] = {nullptr};
+    size_t argCount = 3;
+    napi_status status = napi_get_cb_info(env, info, &argCount, args, &jsThis, nullptr);
+    if (status != napi_ok || jsThis == nullptr) {
+        asyncCtx->SignError(MSERR_EXT_INVALID_VAL, "Failed to napi_get_cb_info");
+    }
+
+    napi_valuetype valueType = napi_undefined;
+    if ((args[0] != nullptr && napi_typeof(env, args[0], &valueType) == napi_ok && valueType == napi_number) &&
+        (args[1] != nullptr && napi_typeof(env, args[1], &valueType) == napi_ok && valueType == napi_number)) {
+        NAPI_CALL(env, napi_get_value_int32(env, args[0], &asyncCtx->sourceId));
+        NAPI_CALL(env, napi_get_value_int32(env, args[1], &asyncCtx->qualityLevel));
+    } else {
+        asyncCtx->SignError(MSERR_EXT_INVALID_VAL, "Illegal argument");
+    }
+
+    asyncCtx->callbackRef = CommonNapi::CreateReference(env, args[2]);
+    asyncCtx->deferred = CommonNapi::CreatePromise(env, asyncCtx->callbackRef, result);
+
+    (void)napi_unwrap(env, jsThis, reinterpret_cast<void **>(&asyncCtx->napi));
+
+    napi_value resource = nullptr;
+    napi_create_string_utf8(env, "HasVideoRecorderProfile", NAPI_AUTO_LENGTH, &resource);
+    NAPI_CALL(env, napi_create_async_work(env, nullptr, resource,
+        [](napi_env env, void* data) {
+            auto asyncCtx = reinterpret_cast<MediaCapsAsyncContext *>(data);
+            if (asyncCtx == nullptr) {
+                MEDIA_LOGE("Failed, asyncCtx is nullptr");
+                return;
+            } else if (asyncCtx->napi == nullptr) {
+                asyncCtx->SignError(MSERR_EXT_UNKNOWN, "nullptr");
+                return;
+            }
+            bool outResult = RecorderProfilesFactory::CreateRecorderProfiles().HasVideoRecorderProfile(
+                asyncCtx->sourceId, asyncCtx->qualityLevel);
+            asyncCtx->JsResult = std::make_unique<MediaJsResultBoolean>(outResult);
+        },
+        MediaAsyncContext::CompleteCallback, static_cast<void *>(asyncCtx.get()), &asyncCtx->work));
+
+    NAPI_CALL(env, napi_queue_async_work(env, asyncCtx->work));
+    asyncCtx.release();
+
+    return result;
+}
+
 napi_value MediaCapsNapi::GetAVMuxerFormatList(napi_env env, napi_callback_info info)
 {
     napi_value result = nullptr;
diff --git a/frameworks/js/mediacapability/media_capability_utils.cpp b/frameworks/js/mediacapability/media_capability_utils.cpp
index 5024e0c2b5d6b0b4a7984082269edd4c287d69ef..251cf88815b23d49423147e373c802bf8245a814 100644
--- a/frameworks/js/mediacapability/media_capability_utils.cpp
+++ b/frameworks/js/mediacapability/media_capability_utils.cpp
@@ -18,6 +18,7 @@
 #include "avcodec_list.h"
 #include "media_log.h"
 #include "media_errors.h"
+#include "recorder_profiles.h"
 
 namespace {
     constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "MediaCapsNapiUtil"};
@@ -214,5 +215,145 @@ napi_status MediaJsVideoCapsDynamic::GetJsResult(napi_env env, napi_value &resul
 
     return napi_ok;
 }
+
+napi_status MediaJsAudioRecorderCapsArray::GetJsResult(napi_env env, napi_value &result)
+{
+    CHECK_AND_RETURN_RET(!value_.empty(), napi_generic_failure);
+
+    napi_status status = napi_create_array_with_length(env, value_.size(), &result);
+    CHECK_AND_RETURN_RET(status == napi_ok, status);
+
+    int32_t index = 0;
+    for (auto it = value_.begin(); it != value_.end(); it++) {
+        CHECK_AND_CONTINUE((*it) != nullptr);
+
+        napi_value obj = nullptr;
+        status = napi_create_object(env, &obj);
+        CHECK_AND_CONTINUE(status == napi_ok);
+
+        std::string outString = (*it)->containerFormatType;
+        (void)CommonNapi::AddStringProperty(env, obj, "outputFormat", outString);
+
+        outString = (*it)->mimeType;
+        (void)CommonNapi::AddStringProperty(env, obj, "audioEncoderMime", outString);
+
+        Range range = (*it)->bitrate;
+        (void)CommonNapi::AddRangeProperty(env, obj, "bitrateRange", range.minVal, range.maxVal);
+
+        std::vector<int32_t> vec = (*it)->sampleRate;
+        (void)CommonNapi::AddArrayProperty(env, obj, "sampleRates", vec);
+
+        range = (*it)->channels;
+        (void)CommonNapi::AddRangeProperty(env, obj, "channelRange", range.minVal, range.maxVal);
+
+        (void)napi_set_element(env, result, index, obj);
+        index++;
+    }
+
+    return status;
+}
+
+napi_status MediaJsVideoRecorderCapsArray::GetJsResult(napi_env env, napi_value &result)
+{
+    CHECK_AND_RETURN_RET(!value_.empty(), napi_generic_failure);
+
+    napi_status status = napi_create_array_with_length(env, value_.size(), &result);
+    CHECK_AND_RETURN_RET(status == napi_ok, status);
+
+    int32_t index = 0;
+    for (auto it = value_.begin(); it != value_.end(); it++) {
+        CHECK_AND_CONTINUE((*it) != nullptr);
+
+        napi_value obj = nullptr;
+        status = napi_create_object(env, &obj);
+        CHECK_AND_CONTINUE(status == napi_ok);
+
+        std::string outString = (*it)->containerFormatType;
+        (void)CommonNapi::AddStringProperty(env, obj, "outputFormat", outString);
+
+        outString = (*it)->audioEncoderMime;
+        (void)CommonNapi::AddStringProperty(env, obj, "audioEncoderMime", outString);
+
+        Range range = (*it)->audioBitrateRange;
+        (void)CommonNapi::AddRangeProperty(env, obj, "audioBitrateRange", range.minVal, range.maxVal);
+
+        std::vector<int32_t> vec = (*it)->audioSampleRates;
+        (void)CommonNapi::AddArrayProperty(env, obj, "audioSampleRates", vec);
+
+        range = (*it)->audioChannelRange;
+        (void)CommonNapi::AddRangeProperty(env, obj, "audioChannelRange", range.minVal, range.maxVal);
+
+        range = (*it)->videoBitrateRange;
+        (void)CommonNapi::AddRangeProperty(env, obj, "videoBitrateRange", range.minVal, range.maxVal);
+
+        range = (*it)->videoFramerateRange;
+        (void)CommonNapi::AddRangeProperty(env, obj, "videoFramerateRange", range.minVal, range.maxVal);
+
+        outString = (*it)->videoEncoderMime;
+        (void)CommonNapi::AddStringProperty(env, obj, "videoEncoderMime", outString);
+
+        range = (*it)->videoWidthRange;
+        (void)CommonNapi::AddRangeProperty(env, obj, "videoWidthRange", range.minVal, range.maxVal);
+
+        range = (*it)->videoHeightRange;
+        (void)CommonNapi::AddRangeProperty(env, obj, "videoHeightRange", range.minVal, range.maxVal);
+
+        (void)napi_set_element(env, result, index, obj);
+        index++;
+    }
+
+    return status;
+}
+
+napi_status MediaJsVideoRecorderProfile::GetJsResult(napi_env env, napi_value &result)
+{
+    napi_status ret = napi_ok;
+    bool setRet = true;
+    CHECK_AND_RETURN_RET(value_ != nullptr, napi_generic_failure);
+    CHECK_AND_RETURN_RET((ret = napi_create_object(env, &result)) == napi_ok, ret);
+
+    setRet = CommonNapi::SetPropertyInt32(env, result, "audioBitrate", value_->audioBitrate);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyInt32(env, result, "audioChannels", value_->audioChannels);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyString(env, result, "audioCodec", value_->audioCodec);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyInt32(env, result, "audioSampleRate", value_->audioSampleRate);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyInt32(env, result, "durationTime", value_->durationTime);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyString(env, result, "fileFormat", value_->containerFormatType);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyInt32(env, result, "qualityLevel", value_->qualityLevel);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyInt32(env, result, "videoBitrate", value_->videoBitrate);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyString(env, result, "videoCodec", value_->videoCodec);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyInt32(env, result, "videoFrameWidth", value_->videoFrameWidth);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyInt32(env, result, "videoFrameHeight", value_->videoFrameHeight);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+    setRet = CommonNapi::SetPropertyInt32(env, result, "videoFrameRate", value_->videoFrameRate);
+    CHECK_AND_RETURN_RET(setRet == true, napi_generic_failure);
+
+    return ret;
+}
+
+bool MediaCapabilityUtil::ExtractAudioRecorderProfile(napi_env env, napi_value profile, AudioRecorderProfile &result)
+{
+    CHECK_AND_RETURN_RET(profile != nullptr, false);
+    bool ret = true;
+    result.containerFormatType = CommonNapi::GetPropertyString(env, profile, "outputFormat");
+    result.audioCodec = CommonNapi::GetPropertyString(env, profile, "audioEncoderMime");
+    ret = CommonNapi::GetPropertyInt32(env, profile, "bitrate", result.audioBitrate);
+    CHECK_AND_RETURN_RET(ret != false, false);
+    ret = CommonNapi::GetPropertyInt32(env, profile, "sampleRate", result.audioSampleRate);
+    CHECK_AND_RETURN_RET(ret != false, false);
+    ret = CommonNapi::GetPropertyInt32(env, profile, "channel", result.audioChannels);
+    CHECK_AND_RETURN_RET(ret != false, false);
+    return ret;
+}
+
 } // namespace Media
 } // namespace OHOS
diff --git a/frameworks/js/mediacapability/media_capability_utils.h b/frameworks/js/mediacapability/media_capability_utils.h
index 95e5f754ba5868f61e2669e63fd62557f14ae653..6cc9290b5d72e8c6d68d063463e7ed2507bb5f4e 100644
--- a/frameworks/js/mediacapability/media_capability_utils.h
+++ b/frameworks/js/mediacapability/media_capability_utils.h
@@ -17,6 +17,7 @@
 #define MEDIA_CAPABILITY_NAPI_UTILS_H
 
 #include "common_napi.h"
+#include "recorder_profiles.h"
 
 namespace OHOS {
 namespace Media {
@@ -75,6 +76,53 @@ private:
     std::string name_;
     bool isDecoder_;
 };
+
+class MediaJsAudioRecorderCapsArray : public MediaJsResult {
+public:
+    explicit MediaJsAudioRecorderCapsArray(std::vector<std::shared_ptr<OHOS::Media::AudioRecorderCaps>> value)
+        : value_(value)
+    {
+    }
+    ~MediaJsAudioRecorderCapsArray() = default;
+    napi_status GetJsResult(napi_env env, napi_value &result) override;
+
+private:
+    std::vector<std::shared_ptr<OHOS::Media::AudioRecorderCaps>> value_;
+};
+
+class MediaJsVideoRecorderCapsArray : public MediaJsResult {
+public:
+    explicit MediaJsVideoRecorderCapsArray(std::vector<std::shared_ptr<OHOS::Media::VideoRecorderCaps>> value)
+        : value_(value)
+    {
+    }
+    ~MediaJsVideoRecorderCapsArray() = default;
+    napi_status GetJsResult(napi_env env, napi_value &result) override;
+
+private:
+    std::vector<std::shared_ptr<OHOS::Media::VideoRecorderCaps>> value_;
+};
+
+class MediaJsVideoRecorderProfile : public MediaJsResult {
+public:
+    explicit MediaJsVideoRecorderProfile(std::shared_ptr<OHOS::Media::VideoRecorderProfile> value)
+        : value_(value)
+    {
+    }
+    ~MediaJsVideoRecorderProfile() = default;
+    napi_status GetJsResult(napi_env env, napi_value &result) override;
+
+private:
+    std::shared_ptr<OHOS::Media::VideoRecorderProfile> value_;
+};
+
+class MediaCapabilityUtil {
+public:
+    MediaCapabilityUtil() = delete;
+    ~MediaCapabilityUtil() = delete;
+    static bool ExtractAudioRecorderProfile(napi_env env, napi_value profile, AudioRecorderProfile &result);
+};
+
 } // namespace Media
 } // namespace OHOS
 #endif
diff --git a/frameworks/native/recorder_profiles/recorder_profiles_impl.cpp b/frameworks/native/recorder_profiles/recorder_profiles_impl.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..764cd2450f1d4a289444e622d3fdfbbeefedbaa0
--- /dev/null
+++ b/frameworks/native/recorder_profiles/recorder_profiles_impl.cpp
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "recorder_profiles_impl.h"
+#include "media_log.h"
+#include "media_errors.h"
+#include "i_media_service.h"
+
+namespace {
+constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "RecorderProfilesImpl"};
+}
+
+namespace OHOS {
+namespace Media {
+RecorderProfiles& RecorderProfilesFactory::CreateRecorderProfiles()
+{
+    return RecorderProfilesImpl::GetInstance();
+}
+
+RecorderProfiles& RecorderProfilesImpl::GetInstance()
+{
+    static RecorderProfilesImpl instance;
+    instance.Init();
+    return instance;
+}
+
+int32_t RecorderProfilesImpl::Init()
+{
+    if (recorderProfilesService_ == nullptr) {
+        recorderProfilesService_ = MediaServiceFactory::GetInstance().CreateRecorderProfilesService();
+    }
+    CHECK_AND_RETURN_RET_LOG(recorderProfilesService_ != nullptr,
+        MSERR_NO_MEMORY, "failed to create RecorderProfiles service");
+    return MSERR_OK;
+}
+
+RecorderProfilesImpl::RecorderProfilesImpl()
+{
+    MEDIA_LOGD("RecorderProfilesImpl:0x%{public}06" PRIXPTR " Instances create", FAKE_POINTER(this));
+}
+
+RecorderProfilesImpl::~RecorderProfilesImpl()
+{
+    if (recorderProfilesService_ != nullptr) {
+        (void)MediaServiceFactory::GetInstance().DestroyMediaProfileService(recorderProfilesService_);
+        recorderProfilesService_ = nullptr;
+    }
+    MEDIA_LOGD("RecorderProfilesImpl:0x%{public}06" PRIXPTR " Instances destroy", FAKE_POINTER(this));
+}
+
+bool RecorderProfilesImpl::IsAudioRecoderConfigSupported(const AudioRecorderProfile &profile)
+{
+    CHECK_AND_RETURN_RET_LOG(recorderProfilesService_ != nullptr, false, "RecorderProfiles service does not exist.");
+    RecorderProfilesData profileData;
+    profileData.containerFormatType = profile.containerFormatType;
+    profileData.audioCodec = profile.audioCodec;
+    profileData.audioBitrate = profile.audioBitrate;
+    profileData.audioSampleRate = profile.audioSampleRate;
+    profileData.audioChannels = profile.audioChannels;
+    return recorderProfilesService_->IsAudioRecoderConfigSupported(profileData);
+}
+
+bool RecorderProfilesImpl::HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel)
+{
+    CHECK_AND_RETURN_RET_LOG(recorderProfilesService_ != nullptr, false, "RecorderProfiles service does not exist.");
+    return recorderProfilesService_->HasVideoRecorderProfile(sourceId, qualityLevel);
+}
+
+std::vector<std::shared_ptr<AudioRecorderCaps>> RecorderProfilesImpl::GetAudioRecorderCaps()
+{
+    std::vector<RecorderProfilesData> capabilityArray = recorderProfilesService_->GetAudioRecorderCapsInfo();
+    std::vector<std::shared_ptr<AudioRecorderCaps>> audioRecorderCapsArray;
+    RecorderProfilesData profileData;
+    for (auto iter = capabilityArray.begin(); iter != capabilityArray.end(); iter++) {
+        profileData = *iter;
+        std::shared_ptr<AudioRecorderCaps> audioRecorderCaps = std::make_shared<AudioRecorderCaps>();
+        CHECK_AND_RETURN_RET_LOG(audioRecorderCaps != nullptr, audioRecorderCapsArray, "Is null mem");
+        audioRecorderCaps->containerFormatType = profileData.containerFormatType;
+        audioRecorderCaps->mimeType = profileData.mimeType;
+        audioRecorderCaps->bitrate = profileData.bitrate;
+        audioRecorderCaps->channels = profileData.channels;
+        audioRecorderCaps->sampleRate = profileData.sampleRate;
+        audioRecorderCapsArray.push_back(audioRecorderCaps);
+    }
+    return audioRecorderCapsArray;
+}
+
+std::vector<std::shared_ptr<VideoRecorderCaps>> RecorderProfilesImpl::GetVideoRecorderCaps()
+{
+    std::vector<RecorderProfilesData> capabilityArray = recorderProfilesService_->GetVideoRecorderCapsInfo();
+    std::vector<std::shared_ptr<VideoRecorderCaps>> videoRecorderCapsArray;
+    RecorderProfilesData profileData;
+    for (auto iter = capabilityArray.begin(); iter != capabilityArray.end(); iter++) {
+        profileData = *iter;
+        std::shared_ptr<VideoRecorderCaps> videoRecorderCaps = std::make_shared<VideoRecorderCaps>();
+        CHECK_AND_RETURN_RET_LOG(videoRecorderCaps != nullptr, videoRecorderCapsArray, "Is null mem");
+        videoRecorderCaps->containerFormatType = profileData.containerFormatType;
+        videoRecorderCaps->audioEncoderMime = profileData.audioEncoderMime;
+        videoRecorderCaps->audioBitrateRange = profileData.audioBitrateRange;
+        videoRecorderCaps->audioSampleRates = profileData.audioSampleRates;
+        videoRecorderCaps->audioChannelRange = profileData.audioChannelRange;
+        videoRecorderCaps->videoBitrateRange = profileData.videoBitrateRange;
+        videoRecorderCaps->videoFramerateRange = profileData.videoFramerateRange;
+        videoRecorderCaps->videoEncoderMime = profileData.videoEncoderMime;
+        videoRecorderCaps->videoWidthRange = profileData.videoWidthRange;
+        videoRecorderCaps->videoHeightRange = profileData.videoHeightRange;
+        videoRecorderCapsArray.push_back(videoRecorderCaps);
+    }
+    return videoRecorderCapsArray;
+}
+
+std::shared_ptr<VideoRecorderProfile> RecorderProfilesImpl::GetVideoRecorderProfile(int32_t sourceId,
+    int32_t qualityLevel)
+{
+    RecorderProfilesData capability = recorderProfilesService_->GetVideoRecorderProfileInfo(sourceId, qualityLevel);
+    std::shared_ptr<VideoRecorderProfile> videoRecorderProfile = std::make_shared<VideoRecorderProfile>();
+    CHECK_AND_RETURN_RET_LOG(videoRecorderProfile != nullptr, videoRecorderProfile, "Is null mem");
+    videoRecorderProfile->containerFormatType = capability.containerFormatType;
+    videoRecorderProfile->audioCodec = capability.audioCodec;
+    videoRecorderProfile->videoCodec = capability.videoCodec;
+    videoRecorderProfile->audioBitrate = capability.audioBitrate;
+    videoRecorderProfile->audioChannels = capability.audioChannels;
+    videoRecorderProfile->audioSampleRate = capability.audioSampleRate;
+    videoRecorderProfile->durationTime = capability.durationTime;
+    videoRecorderProfile->qualityLevel = capability.qualityLevel;
+    videoRecorderProfile->videoBitrate = capability.videoBitrate;
+    videoRecorderProfile->videoFrameWidth = capability.videoFrameWidth;
+    videoRecorderProfile->videoFrameHeight = capability.videoFrameHeight;
+    videoRecorderProfile->videoFrameRate = capability.videoFrameRate;
+    return videoRecorderProfile;
+}
+
+}  // namespace Media
+}  // namespace OHOS
\ No newline at end of file
diff --git a/frameworks/native/recorder_profiles/recorder_profiles_impl.h b/frameworks/native/recorder_profiles/recorder_profiles_impl.h
new file mode 100644
index 0000000000000000000000000000000000000000..7ba762e0e22b593dab44fa18dae6dfa60d1fa61a
--- /dev/null
+++ b/frameworks/native/recorder_profiles/recorder_profiles_impl.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef RECORDERPROFILES_IMPL_H
+#define RECORDERPROFILES_IMPL_H
+
+#include "recorder_profiles.h"
+#include "nocopyable.h"
+#include "i_recorder_profiles_service.h"
+
+namespace OHOS {
+namespace Media {
+class RecorderProfilesImpl : public RecorderProfiles, public NoCopyable {
+public:
+    ~RecorderProfilesImpl();
+    bool IsAudioRecoderConfigSupported(const AudioRecorderProfile &profile) override;
+    bool HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel) override;
+    std::vector<std::shared_ptr<AudioRecorderCaps>> GetAudioRecorderCaps() override;
+    std::vector<std::shared_ptr<VideoRecorderCaps>> GetVideoRecorderCaps() override;
+    std::shared_ptr<VideoRecorderProfile> GetVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel) override;
+    static RecorderProfiles& GetInstance();
+
+private:
+    std::shared_ptr<IRecorderProfilesService> recorderProfilesService_ = nullptr;
+    RecorderProfilesImpl();
+    int32_t Init();
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // RECORDERPROFILES_IMPL_H
+
diff --git a/interfaces/inner_api/native/BUILD.gn b/interfaces/inner_api/native/BUILD.gn
index 53a7ba2ee4d66c95473f3307ee4dc32ffe07e053..c20a766124ed755a8b5091d9c023bee3021beb98 100644
--- a/interfaces/inner_api/native/BUILD.gn
+++ b/interfaces/inner_api/native/BUILD.gn
@@ -25,6 +25,7 @@ config("media_client_local_config") {
     "$MEDIA_ROOT_DIR/services/services/factory",
     "$MEDIA_ROOT_DIR/services/services/engine_intf",
     "$MEDIA_ROOT_DIR/services/services/avcodeclist/server",
+    "$MEDIA_ROOT_DIR/services/services/recorder_profiles/server",
     "$MEDIA_ROOT_DIR/services/services/avmuxer/server",
   ]
 }
@@ -45,6 +46,8 @@ config("media_client_ipc_config") {
     "$MEDIA_ROOT_DIR/services/services/avcodec/ipc",
     "$MEDIA_ROOT_DIR/services/services/avcodeclist/client",
     "$MEDIA_ROOT_DIR/services/services/avcodeclist/ipc",
+    "$MEDIA_ROOT_DIR/services/services/recorder_profiles/client",
+    "$MEDIA_ROOT_DIR/services/services/recorder_profiles/ipc",
     "$MEDIA_ROOT_DIR/services/services/avmuxer/client",
     "$MEDIA_ROOT_DIR/services/services/avmuxer/ipc",
   ]
@@ -99,6 +102,7 @@ ohos_shared_library("media_client") {
       "$MEDIA_ROOT_DIR/frameworks/native/avcodec/avcodec_video_encoder_impl.cpp",
       "$MEDIA_ROOT_DIR/frameworks/native/avcodeclist/avcodec_info.cpp",
       "$MEDIA_ROOT_DIR/frameworks/native/avcodeclist/avcodec_list_impl.cpp",
+      "$MEDIA_ROOT_DIR/frameworks/native/recorder_profiles/recorder_profiles_impl.cpp",
       "$MEDIA_ROOT_DIR/frameworks/native/avmetadatahelper/avmetadatahelper_impl.cpp",
       "$MEDIA_ROOT_DIR/frameworks/native/avmuxer/avmuxer_impl.cpp",
       "$MEDIA_ROOT_DIR/frameworks/native/common/media_errors.cpp",
@@ -106,6 +110,7 @@ ohos_shared_library("media_client") {
       "$MEDIA_ROOT_DIR/frameworks/native/recorder/recorder_impl.cpp",
       "$MEDIA_ROOT_DIR/services/services/avcodec/server/avcodec_server.cpp",
       "$MEDIA_ROOT_DIR/services/services/avcodeclist/server/avcodeclist_server.cpp",
+      "$MEDIA_ROOT_DIR/services/services/recorder_profiles/server/recorder_profiles_server.cpp",
       "$MEDIA_ROOT_DIR/services/services/avmetadatahelper/server/avmetadatahelper_server.cpp",
       "$MEDIA_ROOT_DIR/services/services/avmuxer/server/avmuxer_server.cpp",
       "$MEDIA_ROOT_DIR/services/services/factory/engine_factory_repo.cpp",
@@ -141,6 +146,7 @@ ohos_shared_library("media_client") {
       "$MEDIA_ROOT_DIR/frameworks/native/avcodec/avcodec_video_encoder_impl.cpp",
       "$MEDIA_ROOT_DIR/frameworks/native/avcodeclist/avcodec_info.cpp",
       "$MEDIA_ROOT_DIR/frameworks/native/avcodeclist/avcodec_list_impl.cpp",
+      "$MEDIA_ROOT_DIR/frameworks/native/recorder_profiles/recorder_profiles_impl.cpp",
       "$MEDIA_ROOT_DIR/frameworks/native/avmetadatahelper/avmetadatahelper_impl.cpp",
       "$MEDIA_ROOT_DIR/frameworks/native/avmuxer/avmuxer_impl.cpp",
       "$MEDIA_ROOT_DIR/frameworks/native/common/media_errors.cpp",
@@ -150,7 +156,9 @@ ohos_shared_library("media_client") {
       "$MEDIA_ROOT_DIR/services/services/avcodec/ipc/avcodec_listener_stub.cpp",
       "$MEDIA_ROOT_DIR/services/services/avcodec/ipc/avcodec_service_proxy.cpp",
       "$MEDIA_ROOT_DIR/services/services/avcodeclist/client/avcodeclist_client.cpp",
+      "$MEDIA_ROOT_DIR/services/services/recorder_profiles/client/recorder_profiles_client.cpp",
       "$MEDIA_ROOT_DIR/services/services/avcodeclist/ipc/avcodeclist_service_proxy.cpp",
+      "$MEDIA_ROOT_DIR/services/services/recorder_profiles/ipc/recorder_profiles_service_proxy.cpp",
       "$MEDIA_ROOT_DIR/services/services/avmetadatahelper/client/avmetadatahelper_client.cpp",
       "$MEDIA_ROOT_DIR/services/services/avmetadatahelper/ipc/avmetadatahelper_service_proxy.cpp",
       "$MEDIA_ROOT_DIR/services/services/avmuxer/client/avmuxer_client.cpp",
@@ -165,6 +173,7 @@ ohos_shared_library("media_client") {
       "$MEDIA_ROOT_DIR/services/services/recorder/ipc/recorder_service_proxy.cpp",
       "$MEDIA_ROOT_DIR/services/services/sa_media/client/media_client.cpp",
       "$MEDIA_ROOT_DIR/services/services/sa_media/ipc/avcodeclist_parcel.cpp",
+      "$MEDIA_ROOT_DIR/services/services/sa_media/ipc/recorder_profiles_parcel.cpp",
       "$MEDIA_ROOT_DIR/services/services/sa_media/ipc/media_listener_stub.cpp",
       "$MEDIA_ROOT_DIR/services/services/sa_media/ipc/media_parcel.cpp",
       "$MEDIA_ROOT_DIR/services/services/sa_media/ipc/media_service_proxy.cpp",
diff --git a/interfaces/inner_api/native/avcontainer_common.h b/interfaces/inner_api/native/avcontainer_common.h
index 619f15d9ead2790f5bc0b4358ff014ab7096fe5a..fe016ba9e539ee7207584caeb35751175b5f3ec5 100644
--- a/interfaces/inner_api/native/avcontainer_common.h
+++ b/interfaces/inner_api/native/avcontainer_common.h
@@ -29,6 +29,13 @@ class ContainerFormatType {
 public:
     static constexpr std::string_view CFT_MPEG_4A = "m4a";
     static constexpr std::string_view CFT_MPEG_4 = "mp4";
+    static constexpr std::string_view CFT_MPEG_TS = "mpeg-ts";
+    static constexpr std::string_view CFT_MKV = "mkv";
+    static constexpr std::string_view CFT_WEBM = "webm";
+    static constexpr std::string_view CFT_OGG = "ogg";
+    static constexpr std::string_view CFT_WAV = "wav";
+    static constexpr std::string_view CFT_AAC = "aac";
+    static constexpr std::string_view CFT_FLAC = "flac";
 };
 
 /**
diff --git a/interfaces/inner_api/native/recorder_profiles.h b/interfaces/inner_api/native/recorder_profiles.h
new file mode 100644
index 0000000000000000000000000000000000000000..ab4c6b25722d844b3ac5eb32effe7fc3cc3ca53c
--- /dev/null
+++ b/interfaces/inner_api/native/recorder_profiles.h
@@ -0,0 +1,345 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECORDERPROFILES_H
+#define RECORDERPROFILES_H
+
+#include <cstdint>
+#include <memory>
+#include "recorder_profiles.h"
+#include "avcodec_info.h"
+
+namespace OHOS {
+namespace Media {
+/**
+ * @brief Video recorder quality level
+ *
+ * @since 3.2
+ * @version 3.2
+ */
+enum VideoRecorderQualityLevel : int32_t {
+    /**
+     * Quality level corresponding to the lowest available resolution.
+     * @since 9
+     */
+    RECORDER_QUALITY_LOW = 0,
+
+    /**
+    * Quality level corresponding to the highest available resolution.
+    * @since 9
+    */
+    RECORDER_QUALITY_HIGH = 1,
+
+    /**
+    * Quality level corresponding to the qcif (176 x 144) resolution.
+    * @since 9
+    */
+    RECORDER_QUALITY_QCIF = 2,
+
+    /**
+    * Quality level corresponding to the cif (352 x 288) resolution.
+    * @since 9
+    */
+    RECORDER_QUALITY_CIF = 3,
+
+    /**
+    * Quality level corresponding to the 480p (720 x 480) resolution.
+    * @since 9
+    */
+    RECORDER_QUALITY_480P = 4,
+
+    /**
+    * Quality level corresponding to the 720P (1280 x 720) resolution.
+    * @since 9
+    */
+    RECORDER_QUALITY_720P = 5,
+
+    /**
+    * Quality level corresponding to the 1080P (1920 x 1080) resolution.
+    * @since 9
+    */
+    RECORDER_QUALITY_1080P = 6,
+
+    /**
+    * Quality level corresponding to the QVGA (320x240) resolution.
+    * @since 9
+    */
+    RECORDER_QUALITY_QVGA = 7,
+
+    /**
+    * Quality level corresponding to the 2160p (3840x2160) resolution.
+    * @since 9
+    */
+    RECORDER_QUALITY_2160P = 8,
+
+    /**
+    * Time lapse quality level corresponding to the lowest available resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_TIME_LAPSE_LOW = 100,
+
+    /**
+    * Time lapse quality level corresponding to the highest available resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_TIME_LAPSE_HIGH = 101,
+
+    /**
+    * Time lapse quality level corresponding to the qcif (176 x 144) resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_TIME_LAPSE_QCIF = 102,
+
+    /**
+    * Time lapse quality level corresponding to the cif (352 x 288) resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_TIME_LAPSE_CIF = 103,
+
+    /**
+    * Time lapse quality level corresponding to the 480p (720 x 480) resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_TIME_LAPSE_480P = 104,
+
+    /**
+    * Time lapse quality level corresponding to the 720p (1280 x 720) resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_TIME_LAPSE_720P = 105,
+
+    /**
+    * Time lapse quality level corresponding to the 1080p (1920 x 1088) resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_TIME_LAPSE_1080P = 106,
+
+    /**
+    * Time lapse quality level corresponding to the QVGA (320 x 240) resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_TIME_LAPSE_QVGA = 107,
+
+    /**
+    * Time lapse quality level corresponding to the 2160p (3840 x 2160) resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_TIME_LAPSE_2160P = 108,
+
+    /**
+    * High speed ( >= 100fps) quality level corresponding to the lowest available resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_HIGH_SPEED_LOW = 200,
+
+    /**
+    * High speed ( >= 100fps) quality level corresponding to the highest available resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_HIGH_SPEED_HIGH = 201,
+
+    /**
+    * High speed ( >= 100fps) quality level corresponding to the 480p (720 x 480) resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_HIGH_SPEED_480P = 202,
+
+    /**
+    * High speed ( >= 100fps) quality level corresponding to the 720p (1280 x 720) resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_HIGH_SPEED_720P = 203,
+
+    /**
+    * High speed ( >= 100fps) quality level corresponding to the 1080p (1920 x 1080 or 1920x1088)
+    * resolution.
+    * @since NA
+    */
+    RECORDER_QUALITY_HIGH_SPEED_1080P = 204,
+};
+
+/**
+ * @brief Capability data struct of video recorder caps
+ *
+ * @since 3.2
+ * @version 3.2
+ */
+struct VideoRecorderCaps {
+    std::string containerFormatType = "";
+    std::string audioEncoderMime = "";
+    Range audioBitrateRange;
+    std::vector<int32_t> audioSampleRates;
+    Range audioChannelRange;
+    Range videoBitrateRange;
+    Range videoFramerateRange;
+    std::string videoEncoderMime = "";
+    Range videoWidthRange;
+    Range videoHeightRange;
+};
+
+/**
+ * @brief Capability data struct of audio recorder caps
+ *
+ * @since 3.2
+ * @version 3.2
+ */
+struct AudioRecorderCaps {
+    std::string containerFormatType = "";
+    std::string mimeType = "";
+    Range bitrate;
+    Range channels;
+    std::vector<int32_t> sampleRate;
+};
+
+/**
+ * @brief Capability data struct of video recorder profile
+ *
+ * @since 3.2
+ * @version 3.2
+ */
+struct VideoRecorderProfile {
+    std::string containerFormatType = "";
+    std::string audioCodec = "";
+    std::string videoCodec = "";
+    int32_t audioBitrate = 0;
+    int32_t audioChannels = 0;
+    int32_t audioSampleRate = 0;
+    int32_t durationTime = 0;
+    int32_t qualityLevel = RECORDER_QUALITY_LOW;
+    int32_t videoBitrate = 0;
+    int32_t videoFrameWidth = 0;
+    int32_t videoFrameHeight = 0;
+    int32_t videoFrameRate = 0;
+};
+
+/**
+ * @brief Capability data struct of audio recorder profile
+ *
+ * @since 3.2
+ * @version 3.2
+ */
+struct  AudioRecorderProfile {
+    std::string containerFormatType = "";
+    std::string audioCodec = "";
+    int32_t audioBitrate = 0;
+    int32_t audioSampleRate = 0;
+    int32_t audioChannels = 0;
+};
+
+enum RecorderProfilesType : int32_t {
+    RECORDER_TYPE_NONE = -1,
+    RECORDER_TYPE_AUDIO_CAPS,
+    RECORDER_TYPE_VIDEO_CAPS,
+    RECORDER_TYPE_PROFILE,
+};
+
+/**
+ * @brief Capability data of recorder and profile, parser from config file
+ *
+ * @since 3.2
+ * @version 3.2
+ */
+struct RecorderProfilesData {
+    int32_t mediaProfileType = RECORDER_TYPE_NONE;
+    int32_t sourceId = 0;
+    std::string containerFormatType = "";
+    std::string audioEncoderMime = "";
+    Range audioBitrateRange;
+    std::vector<int32_t> audioSampleRates;
+    Range audioChannelRange;
+    Range videoBitrateRange;
+    Range videoFramerateRange;
+    std::string videoEncoderMime = "";
+    Range videoWidthRange;
+    Range videoHeightRange;
+    std::string mimeType = "";
+    Range bitrate;
+    std::vector<int32_t> sampleRate;
+    Range channels;
+    int32_t audioBitrate = 0;
+    int32_t audioChannels = 0;
+    std::string audioCodec = "";
+    int32_t audioSampleRate = 0;
+    int32_t durationTime = 0;
+    int32_t qualityLevel = RECORDER_QUALITY_LOW;
+    int32_t videoBitrate = 0;
+    std::string videoCodec = "";
+    int32_t videoFrameWidth = 0;
+    int32_t videoFrameHeight = 0;
+    int32_t videoFrameRate = 0;
+};
+
+class RecorderProfiles {
+public:
+    virtual ~RecorderProfiles() = default;
+
+    /**
+     * @brief check wether the audio recorder profile is supported.
+     * @param profile see @AudioRecorderProfile .
+     * @return  Returns the audio profile is support, if support, return true.
+     * @since 3.2
+     * @version 3.2
+     */
+    virtual bool IsAudioRecoderConfigSupported(const AudioRecorderProfile &profile) = 0;
+
+    /**
+     * @brief Checks if there is a profile of the recorder used for a specified sourceId and video record quality.
+     * @param sourceId recorder source id, The lower 16 bits are valid. 8-15 bits indicates the type of source.
+     * 0: camera, 1 virtual display. 0-7 bits indicates corresponding to the id under the source type.
+     * @param qualityLevel record quality level, see @VideoRecorderQualityLevel .
+     * @return  Returns the qualityLevel and sourceId of the video profile is exist, if exist, return true.
+     * @since 3.2
+     * @version 3.2
+     */
+    virtual bool HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel) = 0;
+
+    /**
+     * @brief Get the supported audio recorder capabilities.
+     * @return Returns an array of supported audio recorder capability.
+     * @since 3.2
+     * @version 3.2
+     */
+    virtual std::vector<std::shared_ptr<AudioRecorderCaps>> GetAudioRecorderCaps() = 0;
+
+    /**
+     * @brief Get the supported video recorder capabilities.
+     * @return Returns an array of supported video recorder capability.
+     * @since 3.2
+     * @version 3.2
+     */
+    virtual std::vector<std::shared_ptr<VideoRecorderCaps>> GetVideoRecorderCaps() = 0;
+
+    /**
+     * @brief Get the  video recorder profile used for a specified sourceId and video record quality.
+     * @param sourceId recorder source id, The lower 16 bits are valid. 8-15 bits indicates the type of source.
+     * 0: camera, 1 virtual display. 0-7 bits indicates corresponding to the id under the source type.
+     * @param qualityLevel record quality level, see @VideoRecorderQualityLevel .
+     * @return Returns a supported video recorder profile.
+     * @since 3.2
+     * @version 3.2
+     */
+    virtual std::shared_ptr<VideoRecorderProfile> GetVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel) = 0;
+};
+
+class __attribute__((visibility("default"))) RecorderProfilesFactory {
+public:
+    static RecorderProfiles& CreateRecorderProfiles();
+private:
+    RecorderProfilesFactory() = default;
+    ~RecorderProfilesFactory() = default;
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // RECORDERPROFILES_H
diff --git a/interfaces/kits/js/media_capability_napi.h b/interfaces/kits/js/media_capability_napi.h
index 9d4fe630196c48516e9d5ffc57d604c6fa9f0b4b..bdf05d7a502aafda8505c7269928ecd9c4300177 100644
--- a/interfaces/kits/js/media_capability_napi.h
+++ b/interfaces/kits/js/media_capability_napi.h
@@ -20,6 +20,8 @@
 #include "media_capability_utils.h"
 #include "napi/native_api.h"
 #include "napi/native_node_api.h"
+#include "common_napi.h"
+#include "recorder_profiles.h"
 
 namespace OHOS {
 namespace Media {
@@ -41,6 +43,11 @@ private:
     static napi_value FindVideoDecoder(napi_env env, napi_callback_info info);
     static napi_value GetVideoEncoderCaps(napi_env env, napi_callback_info info);
     static napi_value FindVideoEncoder(napi_env env, napi_callback_info info);
+    static napi_value GetAudioRecorderCaps(napi_env env, napi_callback_info info);
+    static napi_value IsAudioRecoderConfigSupported(napi_env env, napi_callback_info info);
+    static napi_value GetVideoRecorderCaps(napi_env env, napi_callback_info info);
+    static napi_value GetVideoRecorderProfile(napi_env env, napi_callback_info info);
+    static napi_value HasVideoRecorderProfile(napi_env env, napi_callback_info info);
     static napi_value GetAVMuxerFormatList(napi_env env, napi_callback_info info);
 
     MediaCapsNapi();
@@ -57,6 +64,9 @@ struct MediaCapsAsyncContext : public MediaAsyncContext {
 
     MediaCapsNapi *napi = nullptr;
     Format format;
+    int32_t sourceId = 0;
+    int32_t qualityLevel = 0;
+    AudioRecorderProfile profile;
 };
 } // namespace Media
 } // namespace OHOS
diff --git a/services/BUILD.gn b/services/BUILD.gn
index da70239566609eb2b65d17153c9e9908f9b39161..85b537ba652087fb7282b43ea5a9ebe7706cfc41 100644
--- a/services/BUILD.gn
+++ b/services/BUILD.gn
@@ -16,6 +16,7 @@ import("//build/ohos.gni")
 group("media_services_package") {
   deps = [
     ":codec_caps",
+    ":recorder_configs",
     "engine:media_engine_package",
     "etc:media_service.rc",
     "services:media_service",
@@ -29,3 +30,10 @@ ohos_prebuilt_etc("codec_caps") {
   module_install_dir = "etc/codec"
   part_name = "multimedia_media_standard"
 }
+ohos_prebuilt_etc("recorder_configs") {
+  source = "etc/recorder_configs.xml"
+
+  subsystem_name = "multimedia"
+  module_install_dir = "etc/recorder"
+  part_name = "multimedia_media_standard"
+}
\ No newline at end of file
diff --git a/services/engine/common/recorder_profiles/recorder_profiles_ability_singleton.cpp b/services/engine/common/recorder_profiles/recorder_profiles_ability_singleton.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..8884052a81e650ac198960218a81b8ecc865d9cc
--- /dev/null
+++ b/services/engine/common/recorder_profiles/recorder_profiles_ability_singleton.cpp
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "recorder_profiles_ability_singleton.h"
+#include "media_log.h"
+#include "media_errors.h"
+
+namespace {
+    constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "RecorderProfilesAbilitySingleton"};
+}
+
+namespace OHOS {
+namespace Media {
+RecorderProfilesAbilitySingleton& RecorderProfilesAbilitySingleton::GetInstance()
+{
+    static RecorderProfilesAbilitySingleton instance;
+    bool ret = instance.ParseRecorderProfilesXml();
+    if (!ret) {
+        MEDIA_LOGD("ParseRecorderProfilesXml failed");
+    }
+    return instance;
+}
+
+RecorderProfilesAbilitySingleton::RecorderProfilesAbilitySingleton()
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances create", FAKE_POINTER(this));
+}
+
+RecorderProfilesAbilitySingleton::~RecorderProfilesAbilitySingleton()
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances destroy", FAKE_POINTER(this));
+}
+
+bool RecorderProfilesAbilitySingleton::ParseRecorderProfilesXml()
+{
+    if (isParsered_) {
+        return true;
+    }
+    capabilityDataArray_.clear();
+
+    std::shared_ptr<XmlParser> xmlParser = std::make_shared<RecorderProfilesXmlParser>();
+
+    bool ret = xmlParser->LoadConfiguration(MEDIA_PROFILE_CONFIG_FILE);
+    if (!ret) {
+        isParsered_ = false;
+        MEDIA_LOGE("RecorderProfiles LoadConfiguration failed");
+        return false;
+    }
+    ret = xmlParser->Parse();
+    if (!ret) {
+        isParsered_ = false;
+        MEDIA_LOGE("RecorderProfiles Parse failed.");
+        return false;
+    }
+    std::vector<RecorderProfilesData> data = xmlParser->GetRecorderProfileDataArray();
+    capabilityDataArray_.insert(capabilityDataArray_.end(), data.begin(), data.end());
+    isParsered_ = true;
+    return true;
+}
+
+bool RecorderProfilesAbilitySingleton::IsParsered() const
+{
+    return isParsered_;
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesAbilitySingleton::GetCapabilityDataArray() const
+{
+    return capabilityDataArray_;
+}
+}  // namespace Media
+}  // namespace OHOS
diff --git a/services/engine/common/recorder_profiles/recorder_profiles_ability_singleton.h b/services/engine/common/recorder_profiles/recorder_profiles_ability_singleton.h
new file mode 100644
index 0000000000000000000000000000000000000000..adb935732ea4f6db78fffdaacd7b0378cb2d3df6
--- /dev/null
+++ b/services/engine/common/recorder_profiles/recorder_profiles_ability_singleton.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECORDERPROFILESABILITY_SINGLETON_H
+#define RECORDERPROFILESABILITY_SINGLETON_H
+
+#include "format.h"
+#include "recorder_profiles.h"
+#include "recorder_profiles_xml_parser.h"
+
+namespace OHOS {
+namespace Media {
+class RecorderProfilesAbilitySingleton {
+public:
+    const char *MEDIA_PROFILE_CONFIG_FILE = "/etc/recorder/recorder_configs.xml";
+    ~RecorderProfilesAbilitySingleton();
+    static RecorderProfilesAbilitySingleton& GetInstance();
+    std::vector<RecorderProfilesData> GetCapabilityDataArray() const;
+    bool IsParsered() const;
+
+private:
+    bool isParsered_ = false;
+    RecorderProfilesAbilitySingleton();
+    bool ParseRecorderProfilesXml();
+    std::vector<RecorderProfilesData> capabilityDataArray_;
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // RECORDERPROFILESABILITY_SINGLETON_H
\ No newline at end of file
diff --git a/services/engine/common/recorder_profiles/recorder_profiles_xml_parser.cpp b/services/engine/common/recorder_profiles/recorder_profiles_xml_parser.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..028cecd89f0757b471040d5349e092ce0964fc7c
--- /dev/null
+++ b/services/engine/common/recorder_profiles/recorder_profiles_xml_parser.cpp
@@ -0,0 +1,548 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "recorder_profiles_xml_parser.h"
+#include "media_errors.h"
+#include "media_log.h"
+#include "string_ex.h"
+
+namespace {
+    constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "RecorderProfilesXmlParser"};
+}
+
+namespace OHOS {
+namespace Media {
+enum ProfileSourceType : int32_t {
+    PORFILE_SOURCE_CAMERA_RECORDER = 0,
+    PORFILE_SOURCE_VIRTUAL_DISPLAY
+};
+
+const std::vector<std::string> MP4_VIDEO_CODEC_VECTOR = {
+    "video/mp4v-es",
+    "video/avc",
+};
+
+const std::vector<std::string> MP4_AUDIO_CODEC_VECTOR = {
+    "audio/mp4a-latm",
+};
+
+const std::vector<std::string> M4A_AUDIO_CODEC_VECTOR = {
+    "audio/mp4a-latm",
+};
+
+const std::unordered_map<std::string, std::vector<std::string>> RECORDER_VIDEO_CAPS_MAP = {
+    {"mp4", MP4_VIDEO_CODEC_VECTOR},
+};
+
+const std::unordered_map<std::string, std::vector<std::string>> RECORDER_AUDIO_CAPS_MAP = {
+    {"mp4", MP4_AUDIO_CODEC_VECTOR},
+    {"m4a", M4A_AUDIO_CODEC_VECTOR},
+};
+
+const std::unordered_map<std::string, int> SOURCE_TYPE_MAP = {
+    {"CameraRecorder", PORFILE_SOURCE_CAMERA_RECORDER},
+    {"VirtualDisplay", PORFILE_SOURCE_VIRTUAL_DISPLAY},
+};
+
+const std::unordered_map<std::string, std::string> SOURCE_TYPE_ID_MAP = {
+    {"CameraRecorder", "cameraId"},
+    {"VirtualDisplay", "displayId"},
+};
+
+const std::unordered_map<std::string, int> PROFILE_QUALITY_MAP = {
+    {"low", RECORDER_QUALITY_LOW},
+    {"high", RECORDER_QUALITY_HIGH},
+    {"qcif", RECORDER_QUALITY_QCIF},
+    {"cif", RECORDER_QUALITY_CIF},
+    {"480p", RECORDER_QUALITY_480P},
+    {"720p", RECORDER_QUALITY_720P},
+    {"1080p", RECORDER_QUALITY_1080P},
+    {"qvga", RECORDER_QUALITY_QVGA},
+    {"2160p", RECORDER_QUALITY_2160P},
+    {"timelapse_low", RECORDER_QUALITY_TIME_LAPSE_LOW},
+    {"timelapse_high", RECORDER_QUALITY_TIME_LAPSE_HIGH},
+    {"timelapse_qcif", RECORDER_QUALITY_TIME_LAPSE_QCIF},
+    {"timelapse_cif", RECORDER_QUALITY_TIME_LAPSE_CIF},
+    {"timelapse_480p", RECORDER_QUALITY_TIME_LAPSE_480P},
+    {"timelapse_720p", RECORDER_QUALITY_TIME_LAPSE_720P},
+    {"timelapse_1080p", RECORDER_QUALITY_TIME_LAPSE_1080P},
+    {"timelapse_qvga", RECORDER_QUALITY_TIME_LAPSE_QVGA},
+    {"timelapse_2160p", RECORDER_QUALITY_TIME_LAPSE_2160P},
+    {"highspeed_low", RECORDER_QUALITY_HIGH_SPEED_LOW},
+    {"highspeed_high", RECORDER_QUALITY_HIGH_SPEED_HIGH},
+    {"highspeed_480p", RECORDER_QUALITY_HIGH_SPEED_480P},
+    {"highspeed_720p", RECORDER_QUALITY_HIGH_SPEED_720P},
+    {"highspeed_1080p", RECORDER_QUALITY_HIGH_SPEED_1080P},
+};
+
+RecorderProfilesXmlParser::RecorderProfilesXmlParser()
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances create", FAKE_POINTER(this));
+}
+
+RecorderProfilesXmlParser::~RecorderProfilesXmlParser()
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances destroy", FAKE_POINTER(this));
+}
+
+bool RecorderProfilesXmlParser::ParseInternal(xmlNode *node)
+{
+    containerFormatArray_.clear();
+    videoEncoderCapsArray_.clear();
+    audioEncoderCapsArray_.clear();
+    capabilityDataArray_.clear();
+
+    xmlNode *currNode = node;
+    for (; currNode != nullptr; currNode = currNode->next) {
+        if (XML_ELEMENT_NODE == currNode->type) {
+            switch (GetNodeNameAsInt(currNode)) {
+                case RECORDER_CAPS: {
+                    ParseRecorderCapsData(currNode);
+                    break;
+                }
+                case RECORDER_PROFILES: {
+                    ParseRecorderProfilesData(currNode);
+                    break;
+                }
+                default: {
+                    ParseInternal(currNode->children);
+                    break;
+                }
+            }
+        }
+    }
+    return true;
+}
+
+bool RecorderProfilesXmlParser::SetCapabilityIntData(std::unordered_map<std::string, int32_t&> dataMap,
+                                            const std::string &capabilityKey, const std::string &capabilityValue) const
+{
+    if (PROFILE_QUALITY_MAP.find(capabilityValue) != PROFILE_QUALITY_MAP.end()){
+        dataMap.at(capabilityKey) = PROFILE_QUALITY_MAP.at(capabilityValue);
+    } else {
+        int32_t value = 0;
+        if (!StrToInt(capabilityValue, value)) {
+            MEDIA_LOGE("call StrToInt func false, input str is: %{public}s", capabilityValue.c_str());
+            return false;
+        }
+        dataMap.at(capabilityKey) = value;
+    }
+    return true;
+}
+
+bool RecorderProfilesXmlParser::SetCapabilityVectorData(std::unordered_map<std::string, std::vector<int32_t>&> dataMap,
+                                               const std::string &capabilityKey, const std::string &capabilityValue) const
+{
+    std::vector<std::string> spilt;
+    std::vector<int32_t> array;
+    bool ret = SpiltKeyList(capabilityValue, ",", spilt);
+    CHECK_AND_RETURN_RET_LOG(ret != false, false, "failed:can not split %{public}s", capabilityValue.c_str());
+    if (spilt.size() > 0) {
+        std::string probe = spilt[0];
+        if (XmlParser::IsNumberArray(spilt)) {
+            array = TransStrAsIntegerArray(spilt);
+        } else {
+            MEDIA_LOGE("The value of %{public}s in the configuration file is incorrect.", capabilityValue.c_str());
+            return false;
+        }
+        dataMap.at(capabilityKey) = array;
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::SetCapabilityVectorData end");
+    return true;
+}
+
+bool RecorderProfilesXmlParser::ParseRecorderCapsData(xmlNode *node)
+{
+    xmlNode *child = node->xmlChildrenNode;
+    std::string capabilityValue;
+
+    for (; child; child = child->next) {
+        if (0 == xmlStrcmp(child->name, reinterpret_cast<const xmlChar*>("ContainerFormat"))) {
+            bool ret = ParseRecorderContainerFormatData(child);
+            CHECK_AND_RETURN_RET_LOG(ret != false, false, "ParseRecorderContainerFormatData failed");
+        } else if (0 == xmlStrcmp(child->name, reinterpret_cast<const xmlChar*>("VideoEncoderCaps"))) {
+            bool ret = ParseRecorderEncodeCapsData(child, true);
+            CHECK_AND_RETURN_RET_LOG(ret != false, false, "ParseRecorderEncodeCapsData failed");
+        } else if (0 == xmlStrcmp(child->name, reinterpret_cast<const xmlChar*>("AudioEncoderCaps"))) {
+            bool ret = ParseRecorderEncodeCapsData(child, false);
+            CHECK_AND_RETURN_RET_LOG(ret != false, false, "ParseRecorderEncodeCapsData failed");
+        } else {
+            MEDIA_LOGE("not found node!");
+        }
+    }
+    PackageRecorderCaps();
+    MEDIA_LOGD("RecorderProfilesXmlParser::ParseRecorderCapsData end");
+    return true;
+}
+
+bool RecorderProfilesXmlParser::ParseRecorderContainerFormatData(xmlNode *node)
+{
+    ContainerFormatInfo containerFormatInfo;
+    bool ret = false;
+    for (auto it = capabilityKeys_.begin(); it != capabilityKeys_.end(); it++) {
+        std::string capabilityKey = *it;
+        std::string capabilityValue;
+        if (xmlHasProp(node, reinterpret_cast<xmlChar*>(const_cast<char*>(capabilityKey.c_str())))) {
+            capabilityValue = std::string(reinterpret_cast<char*>(xmlGetProp(node,
+                reinterpret_cast<xmlChar*>(const_cast<char*>(capabilityKey.c_str())))));
+            ret = SetContainerFormat(containerFormatInfo, capabilityKey, capabilityValue);
+            CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetContainerFormat failed");
+        }
+    }
+    containerFormatArray_.emplace_back(containerFormatInfo);
+    MEDIA_LOGD("RecorderProfilesXmlParser::ParseRecorderContainerFormatData end");
+    return true;
+}
+
+bool RecorderProfilesXmlParser::ParseRecorderEncodeCapsData(xmlNode *node, bool isVideo)
+{
+    RecorderProfilesData capabilityData;
+    bool ret = false;
+    for (auto it = capabilityKeys_.begin(); it != capabilityKeys_.end(); it++) {
+        std::string capabilityKey = *it;
+        std::string capabilityValue;
+        if (xmlHasProp(node, reinterpret_cast<xmlChar*>(const_cast<char*>(capabilityKey.c_str())))) {
+            capabilityValue = std::string(reinterpret_cast<char*>(xmlGetProp(node,
+                reinterpret_cast<xmlChar*>(const_cast<char*>(capabilityKey.c_str())))));
+            if (isVideo) {
+                ret = SetVideoRecorderCaps(capabilityData, capabilityKey, capabilityValue);
+                CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetVideoRecorderCaps failed");
+            } else {
+                ret = SetAudioRecorderCaps(capabilityData, capabilityKey, capabilityValue);
+                CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetAudioRecorderCaps failed");
+            }
+        }
+    }
+
+    if (isVideo) {
+        videoEncoderCapsArray_.emplace_back(capabilityData);
+    } else {
+        audioEncoderCapsArray_.emplace_back(capabilityData);
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::ParseRecorderEncodeCapsData end");
+    return true;
+}
+
+bool RecorderProfilesXmlParser::SetContainerFormat(ContainerFormatInfo &data, const std::string &capabilityKey,
+                                        const std::string &capabilityValue)
+{
+    std::unordered_map<std::string, std::string&> capabilityStringMap = {
+        {"name", data.name}, {"hasVideo", data.hasVideo}};
+
+    bool ret = false;
+    if (capabilityStringMap.find(capabilityKey) != capabilityStringMap.end()) {
+        ret = SetCapabilityStringData(capabilityStringMap, capabilityKey, capabilityValue);
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetCapabilityStringData failed");
+    } else {
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "can not find capabilityKey: %{public}s", capabilityKey.c_str());
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::SetContainerFormat end");
+    return true;
+}
+
+bool RecorderProfilesXmlParser::SetVideoRecorderCaps(RecorderProfilesData &data, const std::string &capabilityKey,
+                                        const std::string &capabilityValue)
+{
+    std::unordered_map<std::string, std::string&> capabilityStringMap = {
+        {"codecMime", data.videoEncoderMime}};
+
+    std::unordered_map<std::string, Range&> capabilityRangeMap = {
+        {"bitrate", data.videoBitrateRange}, {"width", data.videoWidthRange}, {"height", data.videoHeightRange},
+        {"frameRate", data.videoFramerateRange}};
+
+    bool ret = false;
+    if (capabilityStringMap.find(capabilityKey) != capabilityStringMap.end()) {
+        ret = SetCapabilityStringData(capabilityStringMap, capabilityKey, capabilityValue);
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetCapabilityStringData failed");
+    } else if (capabilityRangeMap.find(capabilityKey) != capabilityRangeMap.end()) {
+        ret = SetCapabilityRangeData(capabilityRangeMap, capabilityKey, capabilityValue);
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetCapabilityRangeData failed");
+    } else {
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "can not find capabilityKey: %{public}s", capabilityKey.c_str());
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::SetVideoRecorderCaps end");
+    return true;
+}
+
+bool RecorderProfilesXmlParser::SetAudioRecorderCaps(RecorderProfilesData &data, const std::string &capabilityKey,
+                                        const std::string &capabilityValue)
+{
+    std::unordered_map<std::string, std::string&> capabilityStringMap = {
+        {"codecMime", data.mimeType}};
+
+    std::unordered_map<std::string, Range&> capabilityRangeMap = {
+        {"bitrate", data.bitrate}, {"channels", data.channels}};
+
+    std::unordered_map<std::string, std::vector<int32_t>&> capabilityVectorMap = {
+        {"sampleRate", data.sampleRate}};
+
+    bool ret = false;
+    if (capabilityStringMap.find(capabilityKey) != capabilityStringMap.end()) {
+        ret = SetCapabilityStringData(capabilityStringMap, capabilityKey, capabilityValue);
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetCapabilityStringData failed");
+    } else if (capabilityRangeMap.find(capabilityKey) != capabilityRangeMap.end()) {
+        ret = SetCapabilityRangeData(capabilityRangeMap, capabilityKey, capabilityValue);
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetCapabilityRangeData failed");
+    } else if (capabilityVectorMap.find(capabilityKey) != capabilityVectorMap.end()) {
+        ret = SetCapabilityVectorData(capabilityVectorMap, capabilityKey, capabilityValue);
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetCapabilityVectorData failed");
+    } else {
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "can not find capabilityKey: %{public}s", capabilityKey.c_str());
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::SetAudioRecorderCaps end");
+    return true;
+}
+
+void RecorderProfilesXmlParser::PackageRecorderCaps()
+{
+    for (auto it = containerFormatArray_.begin(); it != containerFormatArray_.end(); it++) {
+        ContainerFormatInfo  containerFormat = (*it);
+        if ("true" == containerFormat.hasVideo) {
+            PackageVideoRecorderCaps(containerFormat.name);
+        } else {
+            PackageAudioRecorderCaps(containerFormat.name);
+        }
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::PackageRecorderCaps end");
+}
+
+void RecorderProfilesXmlParser::PackageVideoRecorderCaps(const std::string &formatType)
+{
+    if ((RECORDER_VIDEO_CAPS_MAP.find(formatType) == RECORDER_VIDEO_CAPS_MAP.end()) ||
+        (RECORDER_AUDIO_CAPS_MAP.find(formatType) == RECORDER_AUDIO_CAPS_MAP.end())) {
+        MEDIA_LOGE("formatType not found in RECORDER_VIDEO_CAPS_MAP or RECORDER_AUDIO_CAPS_MAP");
+        return;
+    }
+    RecorderProfilesData videoData;
+    for (auto itVideo= videoEncoderCapsArray_.begin(); itVideo != videoEncoderCapsArray_.end(); itVideo++) {
+        videoData = (*itVideo);
+        videoData.mediaProfileType = RECORDER_TYPE_VIDEO_CAPS;
+        videoData.containerFormatType = formatType;
+        auto itVideoCodec = find(RECORDER_VIDEO_CAPS_MAP.at(formatType).begin(),
+            RECORDER_VIDEO_CAPS_MAP.at(formatType).end(), videoData.videoEncoderMime);
+        if (itVideoCodec != RECORDER_VIDEO_CAPS_MAP.at(formatType).end()) {
+            PaddingVideoCapsByAudioCaps(formatType, videoData);
+        }
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::PackageVideoRecorderCaps end");
+}
+
+void RecorderProfilesXmlParser::PaddingVideoCapsByAudioCaps(
+    const std::string &formatType, RecorderProfilesData &videoData)
+{
+    RecorderProfilesData audioData;
+    for (auto itAudio = audioEncoderCapsArray_.begin(); itAudio != audioEncoderCapsArray_.end(); itAudio++) {
+        audioData = (*itAudio);
+        auto itAudioCodec = find(RECORDER_AUDIO_CAPS_MAP.at(formatType).begin(),
+            RECORDER_AUDIO_CAPS_MAP.at(formatType).end(), audioData.mimeType);
+        if (itAudioCodec != RECORDER_AUDIO_CAPS_MAP.at(formatType).end()) {
+            videoData.audioEncoderMime = audioData.mimeType;
+            videoData.audioBitrateRange = audioData.bitrate;
+            videoData.audioSampleRates = audioData.sampleRate;
+            videoData.audioChannelRange = audioData.channels;
+            capabilityDataArray_.emplace_back(videoData);
+        }
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::PaddingVideoCapsByAudioCaps end");
+}
+
+void RecorderProfilesXmlParser::PackageAudioRecorderCaps(const std::string &formatType)
+{
+     if (RECORDER_AUDIO_CAPS_MAP.find(formatType) == RECORDER_AUDIO_CAPS_MAP.end()) {
+        MEDIA_LOGE("formatType not found in RECORDER_AUDIO_CAPS_MAP");
+        return;
+     }
+    for (auto itAudio= audioEncoderCapsArray_.begin(); itAudio != audioEncoderCapsArray_.end(); itAudio++) {
+        RecorderProfilesData audioData = (*itAudio);
+        audioData.mediaProfileType = RECORDER_TYPE_AUDIO_CAPS;
+        audioData.containerFormatType = formatType;
+        auto itAudioCodec = find(RECORDER_AUDIO_CAPS_MAP.at(formatType).begin(),
+            RECORDER_AUDIO_CAPS_MAP.at(formatType).end(), audioData.mimeType);
+        if (itAudioCodec != RECORDER_AUDIO_CAPS_MAP.at(formatType).end()) {
+            capabilityDataArray_.emplace_back(audioData);
+        }
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::PackageAudioRecorderCaps end");
+}
+
+bool RecorderProfilesXmlParser::ParseRecorderProfilesData(xmlNode *node)
+{
+    xmlNode *child = node->xmlChildrenNode;
+    bool ret = false;
+    for (; child; child = child->next) {
+        for (auto it = SOURCE_TYPE_ID_MAP.begin(); it != SOURCE_TYPE_ID_MAP.end(); it++) {
+            std::string sourceType = it->first;
+            ret = ParseRecorderProfilesSourceData(sourceType, child);
+            CHECK_AND_RETURN_RET_LOG(ret != false, false, "ParseRecorderProfilesSourceData failed");
+        }
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::ParseRecorderProfilesData end");
+    return true;
+}
+
+bool RecorderProfilesXmlParser::ParseRecorderProfilesSourceData(const std::string sourceType, xmlNode *node)
+{
+    if (0 == xmlStrcmp(node->name, reinterpret_cast<const xmlChar*>(sourceType.c_str()))) {
+        std::string property = SOURCE_TYPE_ID_MAP.at(sourceType);
+        if (xmlHasProp(node, reinterpret_cast<xmlChar*>(const_cast<char*>(property.c_str())))) {
+            std::string capabilityValue;
+            capabilityValue = std::string(reinterpret_cast<char*>(xmlGetProp(node,
+                reinterpret_cast<xmlChar*>(const_cast<char*>(property.c_str())))));
+            int32_t id = 0;
+            if (!StrToInt(capabilityValue, id)) {
+                MEDIA_LOGE("call StrToInt func false, input str is: %{public}s", capabilityValue.c_str());
+                return false;
+            }
+            if (SOURCE_TYPE_MAP.find(sourceType) == SOURCE_TYPE_MAP.end()) {
+                MEDIA_LOGE("not found sourceType");
+                return false;
+            }
+            int32_t type = SOURCE_TYPE_MAP.at(sourceType);
+            RecorderProfilesData capabilityData;
+            capabilityData.sourceId = ((type & 0x000000ff) << 8) | (id & 0x000000ff);
+            bool ret = ParseRecorderProfileSettingsData(node, capabilityData);
+            CHECK_AND_RETURN_RET_LOG(ret != false, false, "ParseRecorderProfileSettingsData failed");
+        }
+    }
+    return true;
+}
+
+bool RecorderProfilesXmlParser::ParseRecorderProfileSettingsData(xmlNode *node, RecorderProfilesData &capabilityData)
+{
+    xmlNode *child = node->xmlChildrenNode;
+    for (; child; child = child->next) {
+        if (0 == xmlStrcmp(child->name, reinterpret_cast<const xmlChar*>("ProfileSettings"))) {
+            for (auto it = capabilityKeys_.begin(); it != capabilityKeys_.end(); it++) {
+                std::string capabilityKey = *it;
+                if (xmlHasProp(child, reinterpret_cast<xmlChar*>(const_cast<char*>(capabilityKey.c_str())))) {
+                    std::string capabilityValue;
+                    capabilityValue = std::string(reinterpret_cast<char*>(xmlGetProp(child,
+                        reinterpret_cast<xmlChar*>(const_cast<char*>(capabilityKey.c_str())))));
+                    bool ret = SetVideoRecorderProfiles(capabilityData, capabilityKey, capabilityValue);
+                    CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetVideoRecorderProfiles failed");
+                }
+            }
+
+            bool ret = ParseRecorderProfileVideoAudioData(child, capabilityData);
+            CHECK_AND_RETURN_RET_LOG(ret != false, false, "ParseRecorderProfileVideoAudioData failed");
+        }
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::ParseRecorderProfileSettingsData end");
+    return true;
+}
+
+bool RecorderProfilesXmlParser::ParseRecorderProfileVideoAudioData(xmlNode *node,
+    RecorderProfilesData &capabilityData)
+{
+    xmlNode *leafChild = node->xmlChildrenNode;
+    std::string capabilityValue;
+    for (; leafChild; leafChild = leafChild->next) {
+        if (0 == xmlStrcmp(leafChild->name, reinterpret_cast<const xmlChar*>("Video"))) {
+            for (auto it = capabilityKeys_.begin(); it != capabilityKeys_.end(); it++) {
+                std::string capabilityKey = *it;
+                if (xmlHasProp(leafChild, reinterpret_cast<xmlChar*>(const_cast<char*>(capabilityKey.c_str())))) {
+                    capabilityValue = std::string(reinterpret_cast<char*>(xmlGetProp(leafChild,
+                        reinterpret_cast<xmlChar*>(const_cast<char*>(capabilityKey.c_str())))));
+                    capabilityData.mediaProfileType = RECORDER_TYPE_PROFILE;
+                    bool ret = SetVideoRecorderProfiles(capabilityData, capabilityKey, capabilityValue);
+                    CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetVideoRecorderProfiles failed");
+                }
+            }
+        } else if (0 == xmlStrcmp(leafChild->name, reinterpret_cast<const xmlChar*>("Audio"))) {
+            for (auto it = capabilityKeys_.begin(); it != capabilityKeys_.end(); it++) {
+                std::string capabilityKey = *it;
+                if (xmlHasProp(leafChild, reinterpret_cast<xmlChar*>(const_cast<char*>(capabilityKey.c_str())))) {
+                    capabilityValue = std::string(reinterpret_cast<char*>(xmlGetProp(leafChild,
+                        reinterpret_cast<xmlChar*>(const_cast<char*>(capabilityKey.c_str())))));
+                    bool ret = SetAudioRecorderProfiles(capabilityData, capabilityKey, capabilityValue);
+                    CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetAudioRecorderProfiles failed");
+                }
+            }
+        } else {
+            MEDIA_LOGE("not found video or audio node!");
+        }
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::ParseRecorderProfileVideoAudioData end");
+    capabilityDataArray_.emplace_back(capabilityData);
+    return true;
+}
+
+bool RecorderProfilesXmlParser::SetVideoRecorderProfiles(RecorderProfilesData &data, const std::string &capabilityKey,
+                                         const std::string &capabilityValue)
+{
+    std::unordered_map<std::string, std::string&> capabilityStringMap = {
+        {"format", data.containerFormatType}, {"codecMime", data.videoCodec}};
+
+    std::unordered_map<std::string, int32_t&> capabilityIntMap = {
+        {"duration", data.durationTime}, {"bitrate", data.videoBitrate},
+        {"width", data.videoFrameWidth}, {"height", data.videoFrameHeight},
+        {"frameRate", data.videoFrameRate}, {"quality", data.qualityLevel}};
+
+    bool ret = false;
+    if (capabilityStringMap.find(capabilityKey) != capabilityStringMap.end()) {
+        ret = SetCapabilityStringData(capabilityStringMap, capabilityKey, capabilityValue);
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetCapabilityStringData failed");
+    } else if (capabilityIntMap.find(capabilityKey) != capabilityIntMap.end()) {
+        ret = SetCapabilityIntData(capabilityIntMap, capabilityKey, capabilityValue);
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetCapabilityIntData failed");
+    } else {
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "can not find capabilityKey: %{public}s", capabilityKey.c_str());
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::SetVideoRecorderProfiles end");
+    return true;
+}
+
+bool RecorderProfilesXmlParser::SetAudioRecorderProfiles(RecorderProfilesData &data, const std::string &capabilityKey,
+                                        const std::string &capabilityValue)
+{
+    std::unordered_map<std::string, std::string&> capabilityStringMap = {
+        {"format", data.containerFormatType}, {"codecMime", data.audioCodec}};
+
+    std::unordered_map<std::string, int32_t&> capabilityIntMap = {
+        {"bitrate", data.audioBitrate}, {"sampleRate", data.audioSampleRate},
+        {"channels", data.audioChannels}};
+
+    bool ret = false;
+    if (capabilityStringMap.find(capabilityKey) != capabilityStringMap.end()) {
+        ret = SetCapabilityStringData(capabilityStringMap, capabilityKey, capabilityValue);
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetCapabilityStringData failed");
+    } else if (capabilityIntMap.find(capabilityKey) != capabilityIntMap.end()) {
+        ret = SetCapabilityIntData(capabilityIntMap, capabilityKey, capabilityValue);
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "SetCapabilityIntData failed");
+    } else {
+        CHECK_AND_RETURN_RET_LOG(ret != false, false, "can not find capabilityKey: %{public}s", capabilityKey.c_str());
+    }
+    MEDIA_LOGD("RecorderProfilesXmlParser::SetAudioRecorderProfiles end");
+    return true;
+}
+
+RecorderProfilesNodeName RecorderProfilesXmlParser::GetNodeNameAsInt(xmlNode *node)
+{
+    if (!xmlStrcmp(node->name, reinterpret_cast<const xmlChar*>("RecorderConfigurations"))) {
+        return RECORDER_CONFIGURATIONS;
+    } else if (!xmlStrcmp(node->name, reinterpret_cast<const xmlChar*>("RecorderCaps"))) {
+        return RECORDER_CAPS;
+    } else if (!xmlStrcmp(node->name, reinterpret_cast<const xmlChar*>("RecorderProfiles"))) {
+        return RECORDER_PROFILES;
+    } else {
+        return UNKNOWN;
+    }
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesXmlParser::GetRecorderProfileDataArray()
+{
+    return this->capabilityDataArray_;
+}
+}  // namespace Media
+}  // namespace OHOS
\ No newline at end of file
diff --git a/services/engine/common/recorder_profiles/recorder_profiles_xml_parser.h b/services/engine/common/recorder_profiles/recorder_profiles_xml_parser.h
new file mode 100644
index 0000000000000000000000000000000000000000..fc04ec67608b746dd767be34ae68a766c4f16f0c
--- /dev/null
+++ b/services/engine/common/recorder_profiles/recorder_profiles_xml_parser.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECORDERPROFILES_XML_PARSER_H
+#define RECORDERPROFILES_XML_PARSER_H
+
+#include "xml_parse.h"
+
+namespace OHOS {
+namespace Media {
+enum RecorderProfilesNodeName : int32_t {
+    RECORDER_CONFIGURATIONS,
+    RECORDER_CAPS,
+    RECORDER_PROFILES,
+    UNKNOWN,
+};
+
+struct ContainerFormatInfo {
+    std::string name = "";
+    std::string hasVideo = "";
+};
+
+class RecorderProfilesXmlParser : public XmlParser {
+public:
+    RecorderProfilesXmlParser();
+    ~RecorderProfilesXmlParser();
+    std::vector<RecorderProfilesData> GetRecorderProfileDataArray() override;
+
+private:
+    bool ParseInternal(xmlNode *node) override;
+    bool SetCapabilityIntData(std::unordered_map<std::string, int32_t&> dataMap,
+                                const std::string &capabilityKey, const std::string &capabilityValue) const override;
+    bool SetCapabilityVectorData(std::unordered_map<std::string, std::vector<int32_t>&> dataMap,
+                                const std::string &capabilityKey, const std::string &capabilityValue) const override;
+    RecorderProfilesNodeName GetNodeNameAsInt(xmlNode *node);
+    bool SetVideoRecorderProfiles(RecorderProfilesData &data, const std::string &capabilityKey,
+        const std::string &capabilityValue);
+    bool SetAudioRecorderProfiles(RecorderProfilesData &data, const std::string &capabilityKey,
+        const std::string &capabilityValue);
+    bool SetVideoRecorderCaps(RecorderProfilesData &data, const std::string &capabilityKey,
+        const std::string &capabilityValue);
+    bool SetAudioRecorderCaps(RecorderProfilesData &data, const std::string &capabilityKey,
+        const std::string &capabilityValue);
+    bool SetContainerFormat(ContainerFormatInfo &data, const std::string &capabilityKey,
+        const std::string &capabilityValue);
+    bool ParseRecorderCapsData(xmlNode *node);
+    bool ParseRecorderContainerFormatData(xmlNode *node);
+    bool ParseRecorderEncodeCapsData(xmlNode *node, bool isVideo);
+    bool ParseRecorderProfilesData(xmlNode *node);
+    bool ParseRecorderProfilesSourceData(const std::string sourceType, xmlNode *node);
+    bool ParseRecorderProfileSettingsData(xmlNode *node, RecorderProfilesData &capabilityData);
+    bool ParseRecorderProfileVideoAudioData(xmlNode *node, RecorderProfilesData &capabilityData);
+    void PackageRecorderCaps();
+    void PackageVideoRecorderCaps(const std::string &formatType);
+    void PackageAudioRecorderCaps(const std::string &formatType);
+    void PaddingVideoCapsByAudioCaps(const std::string &formatType, RecorderProfilesData &videoData);
+
+    std::vector<ContainerFormatInfo> containerFormatArray_;
+    std::vector<RecorderProfilesData> videoEncoderCapsArray_;
+    std::vector<RecorderProfilesData> audioEncoderCapsArray_;
+    std::vector<RecorderProfilesData> capabilityDataArray_;
+    std::vector<std::string> capabilityKeys_ = {
+        "format",
+        "codecMime",
+        "bitrate",
+        "width",
+        "height",
+        "frameRate",
+        "sampleRate",
+        "channels",
+        "quality",
+        "duration",
+        "name",
+        "hasVideo",
+    };
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // RECORDERPROFILES_XML_PARSER_H
\ No newline at end of file
diff --git a/services/etc/recorder_configs.xml b/services/etc/recorder_configs.xml
new file mode 100644
index 0000000000000000000000000000000000000000..435aa9a243f8481a942f98d9bbbcf18a022fcedf
--- /dev/null
+++ b/services/etc/recorder_configs.xml
@@ -0,0 +1,147 @@
+<?xml version="1.0" encoding="utf-8" ?>
+<!-- Copyright (C) 2022 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     Itemations under the License.
+-->
+<RecorderConfigurations>
+    <RecorderProfiles>
+        <CameraRecorder cameraId="0">
+            <ProfileSettings quality="low" format="mp4" duration="30">
+                <Video codecMime="video/mp4v-es"
+                       bitrate="192000"
+                       width="176"
+                       height="144"
+                       frameRate="30"/>
+
+                <Audio codecMime="audio/mp4a-latm"
+                       bitrate="96000"
+                       sampleRate="48000"
+                       channels="2"/>
+            </ProfileSettings>
+
+            <ProfileSettings quality="high" format="mp4" duration="30">
+                <Video codecMime="video/mp4v-es"
+                       bitrate="17000000"
+                       width="1920"
+                       height="1080"
+                       frameRate="30"/>
+
+                <Audio codecMime="audio/mp4a-latm"
+                       bitrate="192000"
+                       sampleRate="48000"
+                       channels="2"/>
+            </ProfileSettings>
+
+            <ProfileSettings quality="qcif" format="mp4" duration="30">
+                <Video codecMime="video/mp4v-es"
+                       bitrate="192000"
+                       width="176"
+                       height="144"
+                       frameRate="30"/>
+
+                <Audio codecMime="audio/mp4a-latm"
+                       bitrate="96000"
+                       sampleRate="48000"
+                       channels="2"/>
+            </ProfileSettings>
+
+            <ProfileSettings quality="qvga" format="mp4" duration="30">
+                <Video codecMime="video/mp4v-es"
+                       bitrate="1200000"
+                       width="320"
+                       height="240"
+                       frameRate="30"/>
+
+                <Audio codecMime="audio/mp4a-latm"
+                       bitrate="96000"
+                       sampleRate="48000"
+                       channels="2"/>
+            </ProfileSettings>
+
+            <ProfileSettings quality="cif" format="mp4" duration="30">
+                <Video codecMime="video/mp4v-es"
+                       bitrate="1536000"
+                       width="352"
+                       height="288"
+                       frameRate="30"/>
+
+                <Audio codecMime="audio/mp4a-latm"
+                       bitrate="96000"
+                       sampleRate="48000"
+                       channels="2"/>
+            </ProfileSettings>
+
+            <ProfileSettings quality="480p" format="mp4" duration="30">
+                <Video codecMime="video/mp4v-es"
+                       bitrate="5000000"
+                       width="640"
+                       height="480"
+                       frameRate="30"/>
+
+                <Audio codecMime="audio/mp4a-latm"
+                       bitrate="96000"
+                       sampleRate="48000"
+                       channels="2"/>
+            </ProfileSettings>
+
+            <ProfileSettings quality="720p" format="mp4" duration="30">
+                <Video codecMime="video/mp4v-es"
+                       bitrate="12000000"
+                       width="1280"
+                       height="720"
+                       frameRate="30"/>
+
+                <Audio codecMime="audio/mp4a-latm"
+                       bitrate="192000"
+                       sampleRate="48000"
+                       channels="2"/>
+            </ProfileSettings>
+
+            <ProfileSettings quality="1080p" format="mp4" duration="30">
+                <Video codecMime="video/mp4v-es"
+                       bitrate="17000000"
+                       width="1920"
+                       height="1080"
+                       frameRate="30"/>
+
+                <Audio codecMime="audio/mp4a-latm"
+                       bitrate="192000"
+                       sampleRate="48000"
+                       channels="2"/>
+            </ProfileSettings>
+        </CameraRecorder>
+    </RecorderProfiles>
+
+    <RecorderCaps>
+        <ContainerFormat name="mp4" hasVideo="true"/>
+        <ContainerFormat name="m4a" hasVideo="false"/>
+
+        <VideoEncoderCaps codecMime="video/mp4v-es"
+                          bitrate="1-3000000"
+                          width="2-1920"
+                          height="2-1080"
+                          frameRate="1-30"/>
+
+        <VideoEncoderCaps codecMime="video/avc"
+                          bitrate="1-3000000"
+                          width="2-1920"
+                          height="2-1080"
+                          frameRate="1-30"/>
+
+        <AudioEncoderCaps codecMime="audio/mp4a-latm"
+                          bitrate="1-384000"
+                          sampleRate="8000,11025,12000,16000,22050,24000,32000,44100,48000,64000,88200,96000"
+                          channels="1-2"/>
+
+    </RecorderCaps>
+</RecorderConfigurations>
diff --git a/services/include/i_media_service.h b/services/include/i_media_service.h
index 50ddeee8e94880bcdb503caded0869f9ecdbda5a..7859ebc94906ed4468b86d749baa6d7fbc852487 100644
--- a/services/include/i_media_service.h
+++ b/services/include/i_media_service.h
@@ -22,6 +22,7 @@
 #include "i_avmetadatahelper_service.h"
 #include "i_avcodec_service.h"
 #include "i_avcodeclist_service.h"
+#include "i_recorder_profiles_service.h"
 #include "i_avmuxer_service.h"
 
 namespace OHOS {
@@ -63,6 +64,17 @@ public:
      */
     virtual std::shared_ptr<IAVCodecListService> CreateAVCodecListService() = 0;
 
+    /**
+     * @brief Create a mediaprofile service.
+     *
+     * All player functions must be created and obtained first.
+     *
+     * @return Returns a valid pointer if the setting is successful;
+     * @since 3.2
+     * @version 3.2
+     */
+    virtual std::shared_ptr<IRecorderProfilesService> CreateRecorderProfilesService() = 0;
+
     /**
      * @brief Create an avmetadatahelper service.
      *
@@ -156,6 +168,18 @@ public:
      */
     virtual int32_t DestroyAVCodecListService(std::shared_ptr<IAVCodecListService> avCodecList) = 0;
 
+    /**
+     * @brief Destroy a mediaprofile service.
+     *
+     * call the API to destroy the mediaprofile service.
+     *
+     * @param pointer to the mediaprofile service.
+     * @return Returns a valid pointer if the setting is successful;
+     * @since 3.2
+     * @version 3.2
+     */
+    virtual int32_t DestroyMediaProfileService(std::shared_ptr<IRecorderProfilesService> recorderProfiles) = 0;
+    
     /**
      * @brief Destroy a avmuxer service.
      *
diff --git a/services/include/i_recorder_profiles_service.h b/services/include/i_recorder_profiles_service.h
new file mode 100644
index 0000000000000000000000000000000000000000..78caddd28e36feb04c070e7be76ac38f4a0c19e7
--- /dev/null
+++ b/services/include/i_recorder_profiles_service.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef I_MEDIA_PROFILE_SERVICE_H
+#define I_MEDIA_PROFILE_SERVICE_H
+
+#include "recorder_profiles.h"
+#include "avsharedmemory.h"
+
+namespace OHOS {
+namespace Media {
+class IRecorderProfilesService {
+public:
+    virtual ~IRecorderProfilesService() = default;
+    virtual bool IsAudioRecoderConfigSupported(const RecorderProfilesData &profile) = 0;
+    virtual bool HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel) = 0;
+    virtual std::vector<RecorderProfilesData> GetAudioRecorderCapsInfo() = 0;
+    virtual std::vector<RecorderProfilesData> GetVideoRecorderCapsInfo() = 0;
+    virtual RecorderProfilesData GetVideoRecorderProfileInfo(int32_t sourceId, int32_t qualityLevel) = 0;
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif
\ No newline at end of file
diff --git a/services/services/BUILD.gn b/services/services/BUILD.gn
index 0d315d3bec11cec0580f738c4f7937cfbc350b95..f5222c4c4a4dba1860b470763b9ef6907760f2cf 100644
--- a/services/services/BUILD.gn
+++ b/services/services/BUILD.gn
@@ -50,6 +50,8 @@ config("media_service_config") {
     "avcodec/server",
     "avcodeclist/ipc",
     "avcodeclist/server",
+    "recorder_profiles/ipc",
+    "recorder_profiles/server",
     "avmuxer/ipc",
     "avmuxer/server",
     "//base/security/access_token/interfaces/innerkits/access_token/include",
@@ -64,6 +66,7 @@ config("media_service_config") {
     "//utils/native/base/include",
     "//foundation/multimedia/image_standard/interfaces/innerkits/include",
     "//foundation/multimedia/media_standard/services/engine/common/avcodeclist",
+    "//foundation/multimedia/media_standard/services/engine/common/recorder_profiles",
   ]
 
   if (target_cpu == "arm") {
@@ -77,11 +80,15 @@ ohos_shared_library("media_service") {
   sources = [
     "//foundation/multimedia/media_standard/frameworks/native/common/media_errors.cpp",
     "//foundation/multimedia/media_standard/services/utils/avsharedmemorybase.cpp",
+    "//foundation/multimedia/media_standard/services/engine/common/recorder_profiles/recorder_profiles_ability_singleton.cpp",
+    "//foundation/multimedia/media_standard/services/engine/common/recorder_profiles/recorder_profiles_xml_parser.cpp",
     "avcodec/ipc/avcodec_listener_proxy.cpp",
     "avcodec/ipc/avcodec_service_stub.cpp",
     "avcodec/server/avcodec_server.cpp",
     "avcodeclist/ipc/avcodeclist_service_stub.cpp",
     "avcodeclist/server/avcodeclist_server.cpp",
+    "recorder_profiles/ipc/recorder_profiles_service_stub.cpp",
+    "recorder_profiles/server/recorder_profiles_server.cpp",
     "avmetadatahelper/ipc/avmetadatahelper_service_stub.cpp",
     "avmetadatahelper/server/avmetadatahelper_server.cpp",
     "avmuxer/ipc/avmuxer_service_stub.cpp",
@@ -96,6 +103,7 @@ ohos_shared_library("media_service") {
     "recorder/ipc/recorder_service_stub.cpp",
     "recorder/server/recorder_server.cpp",
     "sa_media/ipc/avcodeclist_parcel.cpp",
+    "sa_media/ipc/recorder_profiles_parcel.cpp",
     "sa_media/ipc/media_listener_proxy.cpp",
     "sa_media/ipc/media_parcel.cpp",
     "sa_media/ipc/media_service_stub.cpp",
diff --git a/services/services/recorder_profiles/client/recorder_profiles_client.cpp b/services/services/recorder_profiles/client/recorder_profiles_client.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..c1117c4cbb9f1aa77903843ff4e640b200c7130e
--- /dev/null
+++ b/services/services/recorder_profiles/client/recorder_profiles_client.cpp
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "recorder_profiles_client.h"
+#include "media_log.h"
+#include "media_errors.h"
+
+namespace {
+    constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "RecorderProfilesClient"};
+}
+
+namespace OHOS {
+namespace Media {
+std::shared_ptr<RecorderProfilesClient> RecorderProfilesClient::Create(
+    const sptr<IStandardRecorderProfilesService> &ipcProxy)
+{
+    CHECK_AND_RETURN_RET_LOG(ipcProxy != nullptr, nullptr, "ipcProxy is nullptr..");
+
+    std::shared_ptr<RecorderProfilesClient> recorderProfiles = std::make_shared<RecorderProfilesClient>(ipcProxy);
+    CHECK_AND_RETURN_RET_LOG(recorderProfiles != nullptr, nullptr, "failed to new RecorderProfilesClient..");
+
+    return recorderProfiles;
+}
+
+RecorderProfilesClient::RecorderProfilesClient(const sptr<IStandardRecorderProfilesService> &ipcProxy)
+    : recorderProfilesProxy_(ipcProxy)
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances create", FAKE_POINTER(this));
+}
+
+RecorderProfilesClient::~RecorderProfilesClient()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    if (recorderProfilesProxy_ != nullptr) {
+        (void)recorderProfilesProxy_->DestroyStub();
+    }
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances destroy", FAKE_POINTER(this));
+}
+
+void RecorderProfilesClient::MediaServerDied()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    recorderProfilesProxy_ = nullptr;
+}
+
+bool RecorderProfilesClient::IsAudioRecoderConfigSupported(const RecorderProfilesData &profile)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    CHECK_AND_RETURN_RET_LOG(recorderProfilesProxy_ != nullptr, false, "recorder_profiles service does not exist.");
+    return recorderProfilesProxy_->IsAudioRecoderConfigSupported(profile);
+}
+
+bool RecorderProfilesClient::HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    CHECK_AND_RETURN_RET_LOG(recorderProfilesProxy_ != nullptr, false, "recorder_profiles service does not exist.");
+    return recorderProfilesProxy_->HasVideoRecorderProfile(sourceId, qualityLevel);
+}
+
+RecorderProfilesData RecorderProfilesClient::GetVideoRecorderProfileInfo(int32_t sourceId, int32_t qualityLevel)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    CHECK_AND_RETURN_RET_LOG(recorderProfilesProxy_ != nullptr, RecorderProfilesData(),
+        "recorder_profiles service does not exist.");
+    return recorderProfilesProxy_->GetVideoRecorderProfileInfo(sourceId, qualityLevel);
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesClient::GetAudioRecorderCapsInfo()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    CHECK_AND_RETURN_RET_LOG(recorderProfilesProxy_ != nullptr, std::vector<RecorderProfilesData>(),
+        "recorder_profiles service does not exist.");
+    return recorderProfilesProxy_->GetAudioRecorderCapsInfo();
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesClient::GetVideoRecorderCapsInfo()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    CHECK_AND_RETURN_RET_LOG(recorderProfilesProxy_ != nullptr, std::vector<RecorderProfilesData>(),
+        "recorder_profiles service does not exist.");
+    return recorderProfilesProxy_->GetVideoRecorderCapsInfo();
+}
+}  // namespace Media
+}  // namespace OHOS
diff --git a/services/services/recorder_profiles/client/recorder_profiles_client.h b/services/services/recorder_profiles/client/recorder_profiles_client.h
new file mode 100644
index 0000000000000000000000000000000000000000..2a1e6402bcb59d56f8529bc5834659065e6035fd
--- /dev/null
+++ b/services/services/recorder_profiles/client/recorder_profiles_client.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECORDERPROFILES_SERVICE_CLIENT_H
+#define RECORDERPROFILES_SERVICE_CLIENT_H
+
+#include <mutex>
+#include "i_recorder_profiles_service.h"
+#include "i_standard_recorder_profiles_service.h"
+
+namespace OHOS {
+namespace Media {
+class RecorderProfilesClient : public IRecorderProfilesService {
+public:
+    static std::shared_ptr<RecorderProfilesClient> Create(const sptr<IStandardRecorderProfilesService> &ipcProxy);
+    explicit RecorderProfilesClient(const sptr<IStandardRecorderProfilesService> &ipcProxy);
+    ~RecorderProfilesClient();
+    void MediaServerDied();
+
+    bool IsAudioRecoderConfigSupported(const RecorderProfilesData &profile) override;
+    bool HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel) override;
+    std::vector<RecorderProfilesData> GetAudioRecorderCapsInfo() override;
+    std::vector<RecorderProfilesData> GetVideoRecorderCapsInfo() override;
+    RecorderProfilesData GetVideoRecorderProfileInfo(int32_t sourceId, int32_t qualityLevel) override;
+
+private:
+    sptr<IStandardRecorderProfilesService> recorderProfilesProxy_ = nullptr;
+    std::mutex mutex_;
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // RECORDERPROFILES_SERVICE_CLIENT_H
diff --git a/services/services/recorder_profiles/ipc/i_standard_recorder_profiles_service.h b/services/services/recorder_profiles/ipc/i_standard_recorder_profiles_service.h
new file mode 100644
index 0000000000000000000000000000000000000000..c23fbea76b3a01df2d65908cd74ebba66c867a30
--- /dev/null
+++ b/services/services/recorder_profiles/ipc/i_standard_recorder_profiles_service.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef I_STANDARD_RECORDERPROFILES_SERVICE_H
+#define I_STANDARD_RECORDERPROFILES_SERVICE_H
+
+#include "ipc_types.h"
+#include "iremote_broker.h"
+#include "iremote_proxy.h"
+#include "iremote_stub.h"
+#include "recorder_profiles.h"
+#include "avsharedmemory.h"
+
+namespace OHOS {
+namespace Media {
+class IStandardRecorderProfilesService : public IRemoteBroker {
+public:
+    virtual ~IStandardRecorderProfilesService() = default;
+    virtual bool IsAudioRecoderConfigSupported(const RecorderProfilesData &profile) = 0;
+    virtual bool HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel) = 0;
+    virtual std::vector<RecorderProfilesData> GetAudioRecorderCapsInfo() = 0;
+    virtual std::vector<RecorderProfilesData> GetVideoRecorderCapsInfo() = 0;
+    virtual RecorderProfilesData GetVideoRecorderProfileInfo(int32_t sourceId, int32_t qualityLevel) = 0;
+    virtual int32_t DestroyStub() = 0;
+
+    /**
+     * IPC code ID
+     */
+    enum RecorderProfilesServiceMsg : int32_t {
+        RECORDER_PROFILES_IS_AUDIO_RECORDER_SUPPORT = 1,
+        RECORDER_PROFILES_HAS_VIDEO_RECORD_PROFILE,
+        RECORDER_PROFILES_GET_AUDIO_RECORDER_CAPS,
+        RECORDER_PROFILES_GET_VIDEO_RECORDER_CAPS,
+        RECORDER_PROFILES_GET_VIDEO_RECORDER_PROFILE,
+        RECORDER_PROFILES_DESTROY
+    };
+
+    DECLARE_INTERFACE_DESCRIPTOR(u"IStandardRecorderProfilesService");
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // I_STANDARD_RECORDERPROFILES_SERVICE_H
diff --git a/services/services/recorder_profiles/ipc/recorder_profiles_service_proxy.cpp b/services/services/recorder_profiles/ipc/recorder_profiles_service_proxy.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..df68619dd15c35a42f0d4b44056a574ed6099847
--- /dev/null
+++ b/services/services/recorder_profiles/ipc/recorder_profiles_service_proxy.cpp
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "recorder_profiles_service_proxy.h"
+#include "avsharedmemory_ipc.h"
+#include "media_log.h"
+#include "media_errors.h"
+
+namespace {
+    constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "RecorderProfilesServiceProxy"};
+}
+
+namespace OHOS {
+namespace Media {
+RecorderProfilesServiceProxy::RecorderProfilesServiceProxy(const sptr<IRemoteObject> &impl)
+    : IRemoteProxy<IStandardRecorderProfilesService>(impl)
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances create", FAKE_POINTER(this));
+}
+
+RecorderProfilesServiceProxy::~RecorderProfilesServiceProxy()
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances destroy", FAKE_POINTER(this));
+}
+
+bool RecorderProfilesServiceProxy::IsAudioRecoderConfigSupported(const RecorderProfilesData &profile)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+
+    if (!data.WriteInterfaceToken(RecorderProfilesServiceProxy::GetDescriptor())) {
+        MEDIA_LOGE("Failed to write descriptor");
+        return false;
+    }
+
+    (void)RecorderProfilesParcel::Marshalling(data, profile);
+    int32_t ret = Remote()->SendRequest(RECORDER_PROFILES_IS_AUDIO_RECORDER_SUPPORT, data, reply, option);
+    CHECK_AND_RETURN_RET_LOG(ret == MSERR_OK, false, "IsAudioRecoderConfigSupported failed");
+    return reply.ReadBool();
+}
+
+bool RecorderProfilesServiceProxy::HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+
+    if (!data.WriteInterfaceToken(RecorderProfilesServiceProxy::GetDescriptor())) {
+        MEDIA_LOGE("Failed to write descriptor");
+        return false;
+    }
+
+    data.WriteInt32(sourceId);
+    data.WriteInt32(qualityLevel);
+    int32_t ret  = Remote()->SendRequest(RECORDER_PROFILES_HAS_VIDEO_RECORD_PROFILE, data, reply, option);
+    if (ret != MSERR_OK) {
+        MEDIA_LOGE("HasVideoRecorderProfile failed, error: %{public}d", ret);
+        return false;
+    }
+    return reply.ReadBool();
+}
+
+RecorderProfilesData RecorderProfilesServiceProxy::GetVideoRecorderProfileInfo(int32_t sourceId, int32_t qualityLevel)
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    RecorderProfilesData capabilityData;
+
+    if (!data.WriteInterfaceToken(RecorderProfilesServiceProxy::GetDescriptor())) {
+        MEDIA_LOGE("Failed to write descriptor");
+        return capabilityData;
+    }
+
+    data.WriteInt32(sourceId);
+    data.WriteInt32(qualityLevel);
+    int32_t ret = Remote()->SendRequest(RECORDER_PROFILES_GET_VIDEO_RECORDER_PROFILE, data, reply, option);
+    if (ret != MSERR_OK) {
+        MEDIA_LOGE("GetVideoRecorderProfileInfo failed, error: %{public}d", ret);
+    }
+    (void)RecorderProfilesParcel::Unmarshalling(reply, capabilityData);
+    return capabilityData;
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesServiceProxy::GetAudioRecorderCapsInfo()
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    std::vector<RecorderProfilesData> capabilityDataArray;
+
+    if (!data.WriteInterfaceToken(RecorderProfilesServiceProxy::GetDescriptor())) {
+        MEDIA_LOGE("Failed to write descriptor");
+        return capabilityDataArray;
+    }
+
+    int32_t ret = Remote()->SendRequest(RECORDER_PROFILES_GET_AUDIO_RECORDER_CAPS, data, reply, option);
+    if (ret != MSERR_OK) {
+        MEDIA_LOGE("GetAudioRecorderCapsInfo failed, error: %{public}d", ret);
+    }
+    (void)RecorderProfilesParcel::Unmarshalling(reply, capabilityDataArray);
+    return capabilityDataArray;
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesServiceProxy::GetVideoRecorderCapsInfo()
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+    std::vector<RecorderProfilesData> capabilityDataArray;
+
+    if (!data.WriteInterfaceToken(RecorderProfilesServiceProxy::GetDescriptor())) {
+        MEDIA_LOGE("Failed to write descriptor");
+        return capabilityDataArray;
+    }
+    int32_t ret = Remote()->SendRequest(RECORDER_PROFILES_GET_VIDEO_RECORDER_CAPS, data, reply, option);
+    if (ret != MSERR_OK) {
+        MEDIA_LOGE("GetVideoRecorderCapsInfo failed, error: %{public}d", ret);
+    }
+    (void)RecorderProfilesParcel::Unmarshalling(reply, capabilityDataArray);
+    return capabilityDataArray;
+}
+
+int32_t RecorderProfilesServiceProxy::DestroyStub()
+{
+    MessageParcel data;
+    MessageParcel reply;
+    MessageOption option;
+
+    if (!data.WriteInterfaceToken(RecorderProfilesServiceProxy::GetDescriptor())) {
+        MEDIA_LOGE("Failed to write descriptor");
+        return MSERR_UNKNOWN;
+    }
+
+    int32_t ret = Remote()->SendRequest(RECORDER_PROFILES_DESTROY, data, reply, option);
+    if (ret != MSERR_OK) {
+        MEDIA_LOGE("destroy failed, error: %{public}d", ret);
+    }
+    return reply.ReadInt32();
+}
+
+}  // namespace Media
+}  // namespace OHOS
diff --git a/services/services/recorder_profiles/ipc/recorder_profiles_service_proxy.h b/services/services/recorder_profiles/ipc/recorder_profiles_service_proxy.h
new file mode 100644
index 0000000000000000000000000000000000000000..0b958bdf2678eca5c02059dc2fd2fe6221eadc3f
--- /dev/null
+++ b/services/services/recorder_profiles/ipc/recorder_profiles_service_proxy.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECORDERPROFILES_SERVICE_PROXY_H
+#define RECORDERPROFILES_SERVICE_PROXY_H
+
+#include "i_standard_recorder_profiles_service.h"
+#include "nocopyable.h"
+#include "media_parcel.h"
+#include "recorder_profiles_parcel.h"
+
+namespace OHOS {
+namespace Media {
+class RecorderProfilesServiceProxy : public IRemoteProxy<IStandardRecorderProfilesService>, public NoCopyable {
+public:
+    explicit RecorderProfilesServiceProxy(const sptr<IRemoteObject> &impl);
+    virtual ~RecorderProfilesServiceProxy();
+
+    bool IsAudioRecoderConfigSupported(const RecorderProfilesData &profile) override;
+    bool HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel) override;
+    std::vector<RecorderProfilesData> GetAudioRecorderCapsInfo() override;
+    std::vector<RecorderProfilesData> GetVideoRecorderCapsInfo() override;
+    RecorderProfilesData GetVideoRecorderProfileInfo(int32_t sourceId, int32_t qualityLevel) override;
+    int32_t DestroyStub() override;
+
+private:
+    static inline BrokerDelegator<RecorderProfilesServiceProxy> delegator_;
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // RECORDERPROFILES_SERVICE_PROXY_H
diff --git a/services/services/recorder_profiles/ipc/recorder_profiles_service_stub.cpp b/services/services/recorder_profiles/ipc/recorder_profiles_service_stub.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..f8c011372d934a1667d5419973075b3489c1012c
--- /dev/null
+++ b/services/services/recorder_profiles/ipc/recorder_profiles_service_stub.cpp
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "recorder_profiles_service_stub.h"
+#include <unistd.h>
+#include "avsharedmemory_ipc.h"
+#include "media_errors.h"
+#include "media_log.h"
+#include "media_server_manager.h"
+
+namespace {
+    constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "RecorderProfilesServiceStub"};
+}
+
+namespace OHOS {
+namespace Media {
+sptr<RecorderProfilesServiceStub> RecorderProfilesServiceStub::Create()
+{
+    sptr<RecorderProfilesServiceStub> meidaProfileStub = new(std::nothrow) RecorderProfilesServiceStub();
+    CHECK_AND_RETURN_RET_LOG(meidaProfileStub != nullptr, nullptr, "failed to new RecorderProfilesServiceStub");
+    int32_t ret = meidaProfileStub->Init();
+    CHECK_AND_RETURN_RET_LOG(ret == MSERR_OK, nullptr, "failed to mediaprofile stub init");
+    return meidaProfileStub;
+}
+
+RecorderProfilesServiceStub::RecorderProfilesServiceStub()
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances create", FAKE_POINTER(this));
+}
+
+RecorderProfilesServiceStub::~RecorderProfilesServiceStub()
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances destroy", FAKE_POINTER(this));
+}
+
+int32_t RecorderProfilesServiceStub::Init()
+{
+    mediaProfileServer_ = RecorderProfilesServer::Create();
+    CHECK_AND_RETURN_RET_LOG(
+        mediaProfileServer_ != nullptr, MSERR_NO_MEMORY, "failed to create RecorderProfilesServer");
+    mediaProfileFuncs_[RECORDER_PROFILES_IS_AUDIO_RECORDER_SUPPORT]
+        = &RecorderProfilesServiceStub::IsAudioRecoderConfigSupported;
+    mediaProfileFuncs_[RECORDER_PROFILES_HAS_VIDEO_RECORD_PROFILE]
+        = &RecorderProfilesServiceStub::HasVideoRecorderProfile;
+    mediaProfileFuncs_[RECORDER_PROFILES_GET_AUDIO_RECORDER_CAPS]
+        = &RecorderProfilesServiceStub::GetAudioRecorderCapsInfo;
+    mediaProfileFuncs_[RECORDER_PROFILES_GET_VIDEO_RECORDER_CAPS]
+        = &RecorderProfilesServiceStub::GetVideoRecorderCapsInfo;
+    mediaProfileFuncs_[RECORDER_PROFILES_GET_VIDEO_RECORDER_PROFILE]
+        = &RecorderProfilesServiceStub::GetVideoRecorderProfileInfo;
+    mediaProfileFuncs_[RECORDER_PROFILES_DESTROY]
+        = &RecorderProfilesServiceStub::DestroyStub;
+    return MSERR_OK;
+}
+
+int32_t RecorderProfilesServiceStub::DestroyStub()
+{
+    mediaProfileServer_ = nullptr;
+    MediaServerManager::GetInstance().DestroyStubObject(MediaServerManager::RECORDERPROFILES, AsObject());
+    return MSERR_OK;
+}
+
+int RecorderProfilesServiceStub::OnRemoteRequest(uint32_t code, MessageParcel &data, MessageParcel &reply,
+    MessageOption &option)
+{
+    MEDIA_LOGI("Stub: OnRemoteRequest of code: %{public}u is received", code);
+
+    auto remoteDescriptor = data.ReadInterfaceToken();
+    if (RecorderProfilesServiceStub::GetDescriptor() != remoteDescriptor) {
+        MEDIA_LOGE("Invalid descriptor");
+        return MSERR_INVALID_OPERATION;
+    }
+
+    auto itFunc = mediaProfileFuncs_.find(code);
+    if (itFunc != mediaProfileFuncs_.end()) {
+        auto memberFunc = itFunc->second;
+        if (memberFunc != nullptr) {
+            int32_t ret = (this->*memberFunc)(data, reply);
+            if (ret != MSERR_OK) {
+                MEDIA_LOGE("calling memberFunc is failed.");
+            }
+            return MSERR_OK;
+        }
+    }
+    MEDIA_LOGW("RecorderProfilesServiceStub: no member func supporting, applying default process");
+
+    return IPCObjectStub::OnRemoteRequest(code, data, reply, option);
+}
+
+bool RecorderProfilesServiceStub::IsAudioRecoderConfigSupported(const RecorderProfilesData &profile)
+{
+    CHECK_AND_RETURN_RET_LOG(mediaProfileServer_ != nullptr, false, "recorder_profiles server is nullptr");
+    return mediaProfileServer_->IsAudioRecoderConfigSupported(profile);
+}
+
+bool RecorderProfilesServiceStub::HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel)
+{
+    CHECK_AND_RETURN_RET_LOG(mediaProfileServer_ != nullptr, false, "recorder_profiles server is nullptr");
+    return mediaProfileServer_->HasVideoRecorderProfile(sourceId, qualityLevel);
+}
+
+RecorderProfilesData RecorderProfilesServiceStub::GetVideoRecorderProfileInfo(int32_t sourceId, int32_t qualityLevel)
+{
+    RecorderProfilesData data;
+    CHECK_AND_RETURN_RET_LOG(mediaProfileServer_ != nullptr, data, "recorder_profiles server is nullptr");
+    return mediaProfileServer_->GetVideoRecorderProfileInfo(sourceId, qualityLevel);
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesServiceStub::GetAudioRecorderCapsInfo()
+{
+    CHECK_AND_RETURN_RET_LOG(
+        mediaProfileServer_ != nullptr, std::vector<RecorderProfilesData>(), "recorder_profiles server is nullptr");
+    return mediaProfileServer_->GetAudioRecorderCapsInfo();
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesServiceStub::GetVideoRecorderCapsInfo()
+{
+    CHECK_AND_RETURN_RET_LOG(
+        mediaProfileServer_ != nullptr, std::vector<RecorderProfilesData>(), "recorder_profiles server is nullptr");
+    return mediaProfileServer_->GetVideoRecorderCapsInfo();
+}
+
+int32_t RecorderProfilesServiceStub::IsAudioRecoderConfigSupported(MessageParcel &data, MessageParcel &reply)
+{
+    RecorderProfilesData profile;
+    (void)RecorderProfilesParcel::Unmarshalling(data, profile);
+    reply.WriteBool(IsAudioRecoderConfigSupported(profile));
+    return MSERR_OK;
+}
+
+int32_t RecorderProfilesServiceStub::HasVideoRecorderProfile(MessageParcel &data, MessageParcel &reply)
+{
+    int32_t sourceId = data.ReadInt32();
+    int32_t qualityLevel = data.ReadInt32();
+    reply.WriteBool(HasVideoRecorderProfile(sourceId, qualityLevel));
+    return MSERR_OK;
+}
+
+int32_t RecorderProfilesServiceStub::GetVideoRecorderProfileInfo(MessageParcel &data, MessageParcel &reply)
+{
+    int32_t sourceId = data.ReadInt32();
+    int32_t qualityLevel = data.ReadInt32();
+    RecorderProfilesData capabilityData = GetVideoRecorderProfileInfo(sourceId, qualityLevel);
+    (void)RecorderProfilesParcel::Marshalling(reply, capabilityData);
+    return MSERR_OK;
+}
+
+int32_t RecorderProfilesServiceStub::GetAudioRecorderCapsInfo(MessageParcel &data, MessageParcel &reply)
+{
+    std::string configFile = data.ReadString();
+    std::vector<RecorderProfilesData> capabilityDataArray = GetAudioRecorderCapsInfo();
+    (void)RecorderProfilesParcel::Marshalling(reply, capabilityDataArray);
+    return MSERR_OK;
+}
+
+int32_t RecorderProfilesServiceStub::GetVideoRecorderCapsInfo(MessageParcel &data, MessageParcel &reply)
+{
+    std::string configFile = data.ReadString();
+    std::vector<RecorderProfilesData> capabilityDataArray = GetVideoRecorderCapsInfo();
+    (void)RecorderProfilesParcel::Marshalling(reply, capabilityDataArray);
+    return MSERR_OK;
+}
+
+int32_t RecorderProfilesServiceStub::DestroyStub(MessageParcel &data, MessageParcel &reply)
+{
+    (void)data;
+    reply.WriteInt32(DestroyStub());
+    return MSERR_OK;
+}
+}  // namespace Media
+}  // namespace OHOS
diff --git a/services/services/recorder_profiles/ipc/recorder_profiles_service_stub.h b/services/services/recorder_profiles/ipc/recorder_profiles_service_stub.h
new file mode 100644
index 0000000000000000000000000000000000000000..6046f978171a020e6335fa319a863f2d45668a3c
--- /dev/null
+++ b/services/services/recorder_profiles/ipc/recorder_profiles_service_stub.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECORDERPROFILES_SERVICE_STUB_H
+#define RECORDERPROFILES_SERVICE_STUB_H
+
+#include <map>
+#include "i_standard_recorder_profiles_service.h"
+#include "media_death_recipient.h"
+#include "recorder_profiles_server.h"
+#include "nocopyable.h"
+#include "media_parcel.h"
+#include "recorder_profiles_parcel.h"
+
+namespace OHOS {
+namespace Media {
+class RecorderProfilesServiceStub : public IRemoteStub<IStandardRecorderProfilesService>, public NoCopyable {
+public:
+    static sptr<RecorderProfilesServiceStub> Create();
+    virtual ~RecorderProfilesServiceStub();
+
+    int OnRemoteRequest(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option) override;
+    bool IsAudioRecoderConfigSupported(const RecorderProfilesData &profile) override;
+    bool HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel) override;
+    std::vector<RecorderProfilesData> GetAudioRecorderCapsInfo() override;
+    std::vector<RecorderProfilesData> GetVideoRecorderCapsInfo() override;
+    RecorderProfilesData GetVideoRecorderProfileInfo(int32_t sourceId, int32_t qualityLevel) override;
+    int32_t DestroyStub() override;
+
+private:
+    RecorderProfilesServiceStub();
+    int32_t Init();
+    int32_t IsAudioRecoderConfigSupported(MessageParcel &data, MessageParcel &reply);
+    int32_t HasVideoRecorderProfile(MessageParcel &data, MessageParcel &reply);
+    int32_t GetAudioRecorderCapsInfo(MessageParcel &data, MessageParcel &reply);
+    int32_t GetVideoRecorderCapsInfo(MessageParcel &data, MessageParcel &reply);
+    int32_t GetVideoRecorderProfileInfo(MessageParcel &data, MessageParcel &reply);
+    int32_t DestroyStub(MessageParcel &data, MessageParcel &reply);
+    std::shared_ptr<IRecorderProfilesService> mediaProfileServer_ = nullptr;
+    using MediaProfileStubFunc = int32_t(RecorderProfilesServiceStub::*)(MessageParcel &data, MessageParcel &reply);
+    std::map<uint32_t, MediaProfileStubFunc> mediaProfileFuncs_;
+    std::mutex mutex_;
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // RECORDERPROFILES_SERVICE_STUB_H
diff --git a/services/services/recorder_profiles/server/recorder_profiles_server.cpp b/services/services/recorder_profiles/server/recorder_profiles_server.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..6e9a9add7e22a227e080dbd62a54733a72bbc548
--- /dev/null
+++ b/services/services/recorder_profiles/server/recorder_profiles_server.cpp
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "recorder_profiles_server.h"
+#include "media_log.h"
+#include "media_errors.h"
+#include "engine_factory_repo.h"
+#include "recorder_profiles_ability_singleton.h"
+
+namespace {
+    constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "RecorderProfilesServer"};
+}
+
+namespace OHOS {
+namespace Media {
+std::shared_ptr<IRecorderProfilesService> RecorderProfilesServer::Create()
+{
+    std::shared_ptr<RecorderProfilesServer> server = std::make_shared<RecorderProfilesServer>();
+    return server;
+}
+
+RecorderProfilesServer::RecorderProfilesServer()
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances create", FAKE_POINTER(this));
+}
+
+RecorderProfilesServer::~RecorderProfilesServer()
+{
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances destroy", FAKE_POINTER(this));
+}
+
+bool RecorderProfilesServer::IsAudioRecoderConfigSupported(const RecorderProfilesData &profile)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    bool ret = false;
+    std::vector<RecorderProfilesData> capabilityDataArray = GetCapabilityInfos();
+    for (auto iter = capabilityDataArray.begin(); iter != capabilityDataArray.end(); ++iter) {
+        RecorderProfilesData compareProfileData = (*iter);
+        if (compareProfileData.mediaProfileType == RECORDER_TYPE_PROFILE) {
+            if (compareProfile(compareProfileData, profile)) {
+                ret = true;
+                break;
+            }
+        }
+    }
+    return ret;
+}
+
+bool RecorderProfilesServer::HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    bool ret = false;
+    std::vector<RecorderProfilesData> capabilityDataArray = GetCapabilityInfos();
+    for (auto iter = capabilityDataArray.begin(); iter != capabilityDataArray.end(); ++iter) {
+        if (iter->mediaProfileType == RECORDER_TYPE_PROFILE) {
+            if ((sourceId == iter->sourceId) && (qualityLevel == iter->qualityLevel)) {
+                ret = true;
+                break;
+            }
+        }
+    }
+    return ret;
+}
+
+RecorderProfilesData RecorderProfilesServer::GetVideoRecorderProfileInfo(int32_t sourceId, int32_t qualityLevel)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    RecorderProfilesData capabilityData;
+    std::vector<RecorderProfilesData> capabilityDataArray = GetCapabilityInfos();
+    for (auto iter = capabilityDataArray.begin(); iter != capabilityDataArray.end(); ++iter) {
+        if (iter->mediaProfileType == RECORDER_TYPE_PROFILE) {
+            if ((sourceId == iter->sourceId) && (qualityLevel == iter->qualityLevel)) {
+                capabilityData = (*iter);
+                break;
+            }
+        }
+    }
+    return capabilityData;
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesServer::GetAudioRecorderCapsInfo()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    std::vector<RecorderProfilesData> capabilityDataArray = GetCapabilityInfos();
+    for (auto iter = capabilityDataArray.begin(); iter != capabilityDataArray.end();) {
+        if (iter->mediaProfileType == RECORDER_TYPE_AUDIO_CAPS) {
+            ++iter;
+        } else {
+            iter = capabilityDataArray.erase(iter);
+        }
+    }
+    return capabilityDataArray;
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesServer::GetVideoRecorderCapsInfo()
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    std::vector<RecorderProfilesData> capabilityDataArray = GetCapabilityInfos();
+    for (auto iter = capabilityDataArray.begin(); iter != capabilityDataArray.end();) {
+        if (iter->mediaProfileType == RECORDER_TYPE_VIDEO_CAPS) {
+            ++iter;
+        } else {
+            iter = capabilityDataArray.erase(iter);
+        }
+    }
+    return capabilityDataArray;
+}
+
+std::vector<RecorderProfilesData> RecorderProfilesServer::GetCapabilityInfos()
+{
+    RecorderProfilesAbilitySingleton& mediaProfileAbilityInstance = RecorderProfilesAbilitySingleton::GetInstance();
+    return mediaProfileAbilityInstance.GetCapabilityDataArray();
+}
+
+bool RecorderProfilesServer::compareProfile(
+    const RecorderProfilesData &compareProfile, const RecorderProfilesData &profile)
+{
+    bool ret = false;
+    if ((profile.containerFormatType == compareProfile.containerFormatType) &&
+        (profile.audioCodec == compareProfile.audioCodec) &&
+        (profile.audioBitrate == compareProfile.audioBitrate) &&
+        (profile.audioSampleRate == compareProfile.audioSampleRate) &&
+        (profile.audioChannels == compareProfile.audioChannels)) {
+        ret = true;
+    }
+    return ret;
+}
+}  // namespace Media
+}  // namespace OHOS
diff --git a/services/services/recorder_profiles/server/recorder_profiles_server.h b/services/services/recorder_profiles/server/recorder_profiles_server.h
new file mode 100644
index 0000000000000000000000000000000000000000..a997d8e294c26283fed648d368a7c0fc4bb5f981
--- /dev/null
+++ b/services/services/recorder_profiles/server/recorder_profiles_server.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECORDERPROFILES_SERVER_H
+#define RECORDERPROFILES_SERVER_H
+
+#include "i_recorder_profiles_service.h"
+#include "time_monitor.h"
+#include "nocopyable.h"
+
+namespace OHOS {
+namespace Media {
+class RecorderProfilesServer : public IRecorderProfilesService, public NoCopyable {
+public:
+    static std::shared_ptr<IRecorderProfilesService> Create();
+    RecorderProfilesServer();
+    virtual ~RecorderProfilesServer();
+
+    bool IsAudioRecoderConfigSupported(const RecorderProfilesData &profile) override;
+    bool HasVideoRecorderProfile(int32_t sourceId, int32_t qualityLevel) override;
+    std::vector<RecorderProfilesData> GetAudioRecorderCapsInfo() override;
+    std::vector<RecorderProfilesData> GetVideoRecorderCapsInfo() override;
+    RecorderProfilesData GetVideoRecorderProfileInfo(int32_t sourceId, int32_t qualityLevel) override;
+
+private:
+    bool compareProfile(const RecorderProfilesData &compareProfile, const RecorderProfilesData &profile);
+    std::vector<RecorderProfilesData> GetCapabilityInfos();
+    std::mutex mutex_;
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // RECORDERPROFILES_SERVER_H
\ No newline at end of file
diff --git a/services/services/sa_media/client/media_client.cpp b/services/services/sa_media/client/media_client.cpp
index ace3c447b76f799e2f29256ff4658f97142be902..990264c5b53b83bc5bd52c52a744b953e6b44328 100644
--- a/services/services/sa_media/client/media_client.cpp
+++ b/services/services/sa_media/client/media_client.cpp
@@ -123,6 +123,27 @@ std::shared_ptr<IAVCodecListService> MediaClient::CreateAVCodecListService()
     return avCodecList;
 }
 
+std::shared_ptr<IRecorderProfilesService> MediaClient::CreateRecorderProfilesService()
+{
+    if (!IsAlived()) {
+        MEDIA_LOGE("media service does not exist.");
+        return nullptr;
+    }
+
+    sptr<IRemoteObject> object = mediaProxy_->GetSubSystemAbility(
+        IStandardMediaService::MediaSystemAbility::RECORDER_PROFILES);
+    CHECK_AND_RETURN_RET_LOG(object != nullptr, nullptr, "recorderProfiles proxy object is nullptr.");
+
+    sptr<IStandardRecorderProfilesService> recorderProfilesProxy = iface_cast<IStandardRecorderProfilesService>(object);
+    CHECK_AND_RETURN_RET_LOG(recorderProfilesProxy != nullptr, nullptr, "recorderProfiles proxy is nullptr.");
+
+    std::shared_ptr<RecorderProfilesClient> recorderProfiles = RecorderProfilesClient::Create(recorderProfilesProxy);
+    CHECK_AND_RETURN_RET_LOG(recorderProfiles != nullptr, nullptr, "failed to create recorderProfiles client.");
+
+    std::lock_guard<std::mutex> lock(mutex_);
+    recorderProfilesClientList_.push_back(recorderProfiles);
+    return recorderProfiles;
+}
 std::shared_ptr<IAVMetadataHelperService> MediaClient::CreateAVMetadataHelperService()
 {
     if (!IsAlived()) {
@@ -230,6 +251,14 @@ int32_t MediaClient::DestroyAVCodecListService(std::shared_ptr<IAVCodecListServi
     return MSERR_OK;
 }
 
+int32_t MediaClient::DestroyMediaProfileService(std::shared_ptr<IRecorderProfilesService> recorderProfiles)
+{
+    std::lock_guard<std::mutex> lock(mutex_);
+    CHECK_AND_RETURN_RET_LOG(recorderProfiles != nullptr, MSERR_NO_MEMORY, "input recorderProfiles is nullptr.");
+    recorderProfilesClientList_.remove(recorderProfiles);
+    return MSERR_OK;
+}
+
 int32_t MediaClient::DestroyAVMuxerService(std::shared_ptr<IAVMuxerService> avmuxer)
 {
     std::lock_guard<std::mutex> lock(mutex_);
@@ -312,6 +341,13 @@ void MediaClient::MediaServerDied(pid_t pid)
         }
     }
 
+    for (auto &it : recorderProfilesClientList_) {
+        auto recorderProfilesClient = std::static_pointer_cast<RecorderProfilesClient>(it);
+        if (recorderProfilesClient != nullptr) {
+            recorderProfilesClient->MediaServerDied();
+        }
+    }
+
     for (auto &it : avmuxerClientList_) {
         auto avmuxer = std::static_pointer_cast<AVMuxerClient>(it);
         if (avmuxer != nullptr) {
diff --git a/services/services/sa_media/client/media_client.h b/services/services/sa_media/client/media_client.h
index 16ffae57670033aca1e134fd6d4f724058587009..bbcc94003c8c1bc2959db283cfb33c2f1e1a1970 100644
--- a/services/services/sa_media/client/media_client.h
+++ b/services/services/sa_media/client/media_client.h
@@ -23,6 +23,7 @@
 #include "recorder_client.h"
 #include "player_client.h"
 #include "avcodeclist_client.h"
+#include "recorder_profiles_client.h"
 #include "avmetadatahelper_client.h"
 #include "avcodec_client.h"
 #include "avmuxer_client.h"
@@ -40,12 +41,14 @@ public:
     std::shared_ptr<IAVMetadataHelperService> CreateAVMetadataHelperService() override;
     std::shared_ptr<IAVCodecService> CreateAVCodecService() override;
     std::shared_ptr<IAVCodecListService> CreateAVCodecListService() override;
+    std::shared_ptr<IRecorderProfilesService> CreateRecorderProfilesService() override;
     std::shared_ptr<IAVMuxerService> CreateAVMuxerService() override;
     int32_t DestroyRecorderService(std::shared_ptr<IRecorderService> recorder) override;
     int32_t DestroyPlayerService(std::shared_ptr<IPlayerService> player) override;
     int32_t DestroyAVMetadataHelperService(std::shared_ptr<IAVMetadataHelperService> avMetadataHelper) override;
     int32_t DestroyAVCodecService(std::shared_ptr<IAVCodecService> avCodec) override;
     int32_t DestroyAVCodecListService(std::shared_ptr<IAVCodecListService> avCodecList) override;
+    int32_t DestroyMediaProfileService(std::shared_ptr<IRecorderProfilesService> recorderProfiles) override;
     int32_t DestroyAVMuxerService(std::shared_ptr<IAVMuxerService> avmuxer) override;
 
 private:
@@ -61,6 +64,7 @@ private:
     std::list<std::shared_ptr<IAVMetadataHelperService>> avMetadataHelperClientList_;
     std::list<std::shared_ptr<IAVCodecService>> avCodecClientList_;
     std::list<std::shared_ptr<IAVCodecListService>> avCodecListClientList_;
+    std::list<std::shared_ptr<IRecorderProfilesService>> recorderProfilesClientList_;
     std::list<std::shared_ptr<IAVMuxerService>> avmuxerClientList_;
     std::mutex mutex_;
 };
diff --git a/services/services/sa_media/client/media_local.cpp b/services/services/sa_media/client/media_local.cpp
index ab59f18d14f85b80d1777b3bec5945f7874df30d..54059cadf8a3a08fe90ce624ba817d44c26d07c7 100644
--- a/services/services/sa_media/client/media_local.cpp
+++ b/services/services/sa_media/client/media_local.cpp
@@ -21,6 +21,7 @@
 #include "player_server.h"
 #include "recorder_server.h"
 #include "avcodeclist_server.h"
+#include "recorder_profiles_server.h"
 #include "avmuxer_server.h"
 
 namespace OHOS {
@@ -56,6 +57,11 @@ std::shared_ptr<IAVCodecListService> MediaLocal::CreateAVCodecListService()
     return AVCodecListServer::Create();
 }
 
+std::shared_ptr<IRecorderProfilesService> MediaLocal::CreateRecorderProfilesService()
+{
+    return RecorderProfilesServer::Create();
+}
+
 std::shared_ptr<IAVMuxerService> MediaLocal::CreateAVMuxerService()
 {
     return AVMuxerServer::Create();
@@ -90,6 +96,13 @@ int32_t MediaLocal::DestroyAVCodecListService(std::shared_ptr<IAVCodecListServic
     (void)avCodecList;
     return MSERR_OK;
 }
+
+int32_t MediaLocal::DestroyMediaProfileService(std::shared_ptr<IRecorderProfilesService> recorderProfiles)
+{
+    (void)recorderProfiles;
+    return MSERR_OK;
+}
+
 int32_t MediaLocal::DestroyAVMuxerService(std::shared_ptr<IAVMuxerService> avmuxer)
 {
     (void)avmuxer;
diff --git a/services/services/sa_media/client/media_local.h b/services/services/sa_media/client/media_local.h
index c12c0320d77aeeb6c975a7625c3e4071430fcadf..c4b13d4021b23d5ae573ec3d262ebfa88563e5ea 100644
--- a/services/services/sa_media/client/media_local.h
+++ b/services/services/sa_media/client/media_local.h
@@ -31,12 +31,14 @@ public:
     std::shared_ptr<IAVMetadataHelperService> CreateAVMetadataHelperService() override;
     std::shared_ptr<IAVCodecService> CreateAVCodecService() override;
     std::shared_ptr<IAVCodecListService> CreateAVCodecListService() override;
+    std::shared_ptr<IRecorderProfilesService> CreateRecorderProfilesService() override;
     std::shared_ptr<IAVMuxerService> CreateAVMuxerService() override;
     int32_t DestroyRecorderService(std::shared_ptr<IRecorderService> recorder) override;
     int32_t DestroyPlayerService(std::shared_ptr<IPlayerService> player) override;
     int32_t DestroyAVMetadataHelperService(std::shared_ptr<IAVMetadataHelperService> avMetadataHelper) override;
     int32_t DestroyAVCodecService(std::shared_ptr<IAVCodecService> avCodec) override;
     int32_t DestroyAVCodecListService(std::shared_ptr<IAVCodecListService> avCodecList) override;
+    int32_t DestroyMediaProfileService(std::shared_ptr<IRecorderProfilesService> recorderProfiles) override;
     int32_t DestroyAVMuxerService(std::shared_ptr<IAVMuxerService> avmuxer) override;
 };
 } // namespace Media
diff --git a/services/services/sa_media/ipc/i_standard_media_service.h b/services/services/sa_media/ipc/i_standard_media_service.h
index ea62bb47d7a1562aab9d7fbd235ab6cbdb5cc47b..2c444e68b37c49a05bbbb561492e859e38c82f82 100644
--- a/services/services/sa_media/ipc/i_standard_media_service.h
+++ b/services/services/sa_media/ipc/i_standard_media_service.h
@@ -36,6 +36,7 @@ public:
         MEDIA_CODECLIST = 4,
         MEDIA_AVCODEC = 5,
         MEDIA_AVMUXER = 6,
+        RECORDER_PROFILES = 7,
     };
 
     /**
diff --git a/services/services/sa_media/ipc/recorder_profiles_parcel.cpp b/services/services/sa_media/ipc/recorder_profiles_parcel.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..eef8e1e57287364563078b0004a1283612e0be82
--- /dev/null
+++ b/services/services/sa_media/ipc/recorder_profiles_parcel.cpp
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "recorder_profiles_parcel.h"
+#include "media_log.h"
+
+namespace {
+constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "RecorderProfilesParcel"};
+}
+
+namespace OHOS {
+namespace Media {
+bool RecorderProfilesParcel::Marshalling(
+    MessageParcel &parcel, const std::vector<RecorderProfilesData> &profileCapabilityDataArray)
+{
+    parcel.WriteUint32(profileCapabilityDataArray.size());
+    for (auto it = profileCapabilityDataArray.begin(); it != profileCapabilityDataArray.end(); it++) {
+        //  string
+        (void)parcel.WriteString(it->containerFormatType);
+        (void)parcel.WriteString(it->mimeType);
+        (void)parcel.WriteString(it->audioEncoderMime);
+        (void)parcel.WriteString(it->videoEncoderMime);
+        (void)parcel.WriteString(it->audioCodec);
+        (void)parcel.WriteString(it->videoCodec);
+
+        //  Range
+        (void)parcel.WriteInt32(it->bitrate.minVal);
+        (void)parcel.WriteInt32(it->bitrate.maxVal);
+        (void)parcel.WriteInt32(it->channels.minVal);
+        (void)parcel.WriteInt32(it->channels.maxVal);
+        (void)parcel.WriteInt32(it->audioBitrateRange.minVal);
+        (void)parcel.WriteInt32(it->audioBitrateRange.maxVal);
+        (void)parcel.WriteInt32(it->audioChannelRange.minVal);
+        (void)parcel.WriteInt32(it->audioChannelRange.maxVal);
+        (void)parcel.WriteInt32(it->videoBitrateRange.minVal);
+        (void)parcel.WriteInt32(it->videoBitrateRange.maxVal);
+        (void)parcel.WriteInt32(it->videoFramerateRange.minVal);
+        (void)parcel.WriteInt32(it->videoFramerateRange.maxVal);
+        (void)parcel.WriteInt32(it->videoWidthRange.minVal);
+        (void)parcel.WriteInt32(it->videoWidthRange.maxVal);
+        (void)parcel.WriteInt32(it->videoHeightRange.minVal);
+        (void)parcel.WriteInt32(it->videoHeightRange.maxVal);
+
+        //  int32_t
+        (void)parcel.WriteInt32(it->sourceId);
+        (void)parcel.WriteInt32(it->mediaProfileType);
+        (void)parcel.WriteInt32(it->audioBitrate);
+        (void)parcel.WriteInt32(it->audioChannels);
+        (void)parcel.WriteInt32(it->audioSampleRate);
+        (void)parcel.WriteInt32(it->durationTime);
+        (void)parcel.WriteInt32(it->qualityLevel);
+        (void)parcel.WriteInt32(it->videoBitrate);
+        (void)parcel.WriteInt32(it->videoFrameWidth);
+        (void)parcel.WriteInt32(it->videoFrameHeight);
+        (void)parcel.WriteInt32(it->videoFrameRate);
+
+        //  std::vector<int32_t>
+        (void)parcel.WriteInt32Vector(it->sampleRate);
+        (void)parcel.WriteInt32Vector(it->audioSampleRates);
+    }
+    MEDIA_LOGD("success to Marshalling profileCapabilityDataArray");
+
+    return true;
+}
+
+bool RecorderProfilesParcel::Marshalling(MessageParcel &parcel, const RecorderProfilesData &profileCapabilityData)
+{
+        //  string
+        (void)parcel.WriteString(profileCapabilityData.containerFormatType);
+        (void)parcel.WriteString(profileCapabilityData.mimeType);
+        (void)parcel.WriteString(profileCapabilityData.audioEncoderMime);
+        (void)parcel.WriteString(profileCapabilityData.videoEncoderMime);
+        (void)parcel.WriteString(profileCapabilityData.audioCodec);
+        (void)parcel.WriteString(profileCapabilityData.videoCodec);
+
+        //  Range
+        (void)parcel.WriteInt32(profileCapabilityData.bitrate.minVal);
+        (void)parcel.WriteInt32(profileCapabilityData.bitrate.maxVal);
+        (void)parcel.WriteInt32(profileCapabilityData.channels.minVal);
+        (void)parcel.WriteInt32(profileCapabilityData.channels.maxVal);
+        (void)parcel.WriteInt32(profileCapabilityData.audioBitrateRange.minVal);
+        (void)parcel.WriteInt32(profileCapabilityData.audioBitrateRange.maxVal);
+        (void)parcel.WriteInt32(profileCapabilityData.audioChannelRange.minVal);
+        (void)parcel.WriteInt32(profileCapabilityData.audioChannelRange.maxVal);
+        (void)parcel.WriteInt32(profileCapabilityData.videoBitrateRange.minVal);
+        (void)parcel.WriteInt32(profileCapabilityData.videoBitrateRange.maxVal);
+        (void)parcel.WriteInt32(profileCapabilityData.videoFramerateRange.minVal);
+        (void)parcel.WriteInt32(profileCapabilityData.videoFramerateRange.maxVal);
+        (void)parcel.WriteInt32(profileCapabilityData.videoWidthRange.minVal);
+        (void)parcel.WriteInt32(profileCapabilityData.videoWidthRange.maxVal);
+        (void)parcel.WriteInt32(profileCapabilityData.videoHeightRange.minVal);
+        (void)parcel.WriteInt32(profileCapabilityData.videoHeightRange.maxVal);
+
+        //  int32_t
+        (void)parcel.WriteInt32(profileCapabilityData.sourceId);
+        (void)parcel.WriteInt32(profileCapabilityData.mediaProfileType);
+        (void)parcel.WriteInt32(profileCapabilityData.audioBitrate);
+        (void)parcel.WriteInt32(profileCapabilityData.audioChannels);
+        (void)parcel.WriteInt32(profileCapabilityData.audioSampleRate);
+        (void)parcel.WriteInt32(profileCapabilityData.durationTime);
+        (void)parcel.WriteInt32(profileCapabilityData.qualityLevel);
+        (void)parcel.WriteInt32(profileCapabilityData.videoBitrate);
+        (void)parcel.WriteInt32(profileCapabilityData.videoFrameWidth);
+        (void)parcel.WriteInt32(profileCapabilityData.videoFrameHeight);
+        (void)parcel.WriteInt32(profileCapabilityData.videoFrameRate);
+
+        //  std::vector<int32_t>
+        (void)parcel.WriteInt32Vector(profileCapabilityData.sampleRate);
+        (void)parcel.WriteInt32Vector(profileCapabilityData.audioSampleRates);
+
+    MEDIA_LOGD("success to Marshalling profileCapabilityData");
+
+    return true;
+}
+
+bool RecorderProfilesParcel::Unmarshalling(
+    MessageParcel &parcel, std::vector<RecorderProfilesData> &profileCapabilityDataArray)
+{
+    uint32_t size = parcel.ReadUint32();
+    for (uint32_t index = 0; index < size; index++) {
+        RecorderProfilesData profileCapabilityData;
+
+        //  string
+        profileCapabilityData.containerFormatType = parcel.ReadString();
+        profileCapabilityData.mimeType = parcel.ReadString();
+        profileCapabilityData.audioEncoderMime = parcel.ReadString();
+        profileCapabilityData.videoEncoderMime = parcel.ReadString();
+        profileCapabilityData.audioCodec = parcel.ReadString();
+        profileCapabilityData.videoCodec = parcel.ReadString();
+
+        //  Range
+        profileCapabilityData.bitrate.minVal = parcel.ReadInt32();
+        profileCapabilityData.bitrate.maxVal = parcel.ReadInt32();
+        profileCapabilityData.channels.minVal = parcel.ReadInt32();
+        profileCapabilityData.channels.maxVal = parcel.ReadInt32();
+        profileCapabilityData.audioBitrateRange.minVal = parcel.ReadInt32();
+        profileCapabilityData.audioBitrateRange.maxVal = parcel.ReadInt32();
+        profileCapabilityData.audioChannelRange.minVal = parcel.ReadInt32();
+        profileCapabilityData.audioChannelRange.maxVal = parcel.ReadInt32();
+        profileCapabilityData.videoBitrateRange.minVal = parcel.ReadInt32();
+        profileCapabilityData.videoBitrateRange.maxVal = parcel.ReadInt32();
+        profileCapabilityData.videoFramerateRange.minVal = parcel.ReadInt32();
+        profileCapabilityData.videoFramerateRange.maxVal = parcel.ReadInt32();
+        profileCapabilityData.videoWidthRange.minVal = parcel.ReadInt32();
+        profileCapabilityData.videoWidthRange.maxVal = parcel.ReadInt32();
+        profileCapabilityData.videoHeightRange.minVal = parcel.ReadInt32();
+        profileCapabilityData.videoHeightRange.maxVal = parcel.ReadInt32();
+
+        //  int32_t
+        profileCapabilityData.sourceId = parcel.ReadInt32();
+        profileCapabilityData.mediaProfileType = parcel.ReadInt32();
+        profileCapabilityData.audioBitrate = parcel.ReadInt32();
+        profileCapabilityData.audioChannels = parcel.ReadInt32();
+        profileCapabilityData.audioSampleRate = parcel.ReadInt32();
+        profileCapabilityData.durationTime = parcel.ReadInt32();
+        profileCapabilityData.qualityLevel = parcel.ReadInt32();
+        profileCapabilityData.videoBitrate = parcel.ReadInt32();
+        profileCapabilityData.videoFrameWidth = parcel.ReadInt32();
+        profileCapabilityData.videoFrameHeight = parcel.ReadInt32();
+        profileCapabilityData.videoFrameRate = parcel.ReadInt32();
+
+        //  std::vector<int32_t>
+        parcel.ReadInt32Vector(&profileCapabilityData.sampleRate);
+        parcel.ReadInt32Vector(&profileCapabilityData.audioSampleRates);
+
+        profileCapabilityDataArray.push_back(profileCapabilityData);
+    }
+    MEDIA_LOGD("success to Unmarshalling profileCapabilityDataArray");
+
+    return true;
+}
+
+bool RecorderProfilesParcel::Unmarshalling(MessageParcel &parcel, RecorderProfilesData &profileCapabilityData)
+{
+    //  string
+    profileCapabilityData.containerFormatType = parcel.ReadString();
+    profileCapabilityData.mimeType = parcel.ReadString();
+    profileCapabilityData.audioEncoderMime = parcel.ReadString();
+    profileCapabilityData.videoEncoderMime = parcel.ReadString();
+    profileCapabilityData.audioCodec = parcel.ReadString();
+    profileCapabilityData.videoCodec = parcel.ReadString();
+
+    //  Range
+    profileCapabilityData.bitrate.minVal = parcel.ReadInt32();
+    profileCapabilityData.bitrate.maxVal = parcel.ReadInt32();
+    profileCapabilityData.channels.minVal = parcel.ReadInt32();
+    profileCapabilityData.channels.maxVal = parcel.ReadInt32();
+    profileCapabilityData.audioBitrateRange.minVal = parcel.ReadInt32();
+    profileCapabilityData.audioBitrateRange.maxVal = parcel.ReadInt32();
+    profileCapabilityData.audioChannelRange.minVal = parcel.ReadInt32();
+    profileCapabilityData.audioChannelRange.maxVal = parcel.ReadInt32();
+    profileCapabilityData.videoBitrateRange.minVal = parcel.ReadInt32();
+    profileCapabilityData.videoBitrateRange.maxVal = parcel.ReadInt32();
+    profileCapabilityData.videoFramerateRange.minVal = parcel.ReadInt32();
+    profileCapabilityData.videoFramerateRange.maxVal = parcel.ReadInt32();
+    profileCapabilityData.videoWidthRange.minVal = parcel.ReadInt32();
+    profileCapabilityData.videoWidthRange.maxVal = parcel.ReadInt32();
+    profileCapabilityData.videoHeightRange.minVal = parcel.ReadInt32();
+    profileCapabilityData.videoHeightRange.maxVal = parcel.ReadInt32();
+
+    //  int32_t
+    profileCapabilityData.sourceId = parcel.ReadInt32();
+    profileCapabilityData.mediaProfileType = parcel.ReadInt32();
+    profileCapabilityData.audioBitrate = parcel.ReadInt32();
+    profileCapabilityData.audioChannels = parcel.ReadInt32();
+    profileCapabilityData.audioSampleRate = parcel.ReadInt32();
+    profileCapabilityData.durationTime = parcel.ReadInt32();
+    profileCapabilityData.qualityLevel = parcel.ReadInt32();
+    profileCapabilityData.videoBitrate = parcel.ReadInt32();
+    profileCapabilityData.videoFrameWidth = parcel.ReadInt32();
+    profileCapabilityData.videoFrameHeight = parcel.ReadInt32();
+    profileCapabilityData.videoFrameRate = parcel.ReadInt32();
+
+    //  std::vector<int32_t>
+    parcel.ReadInt32Vector(&profileCapabilityData.sampleRate);
+    parcel.ReadInt32Vector(&profileCapabilityData.audioSampleRates);
+
+    MEDIA_LOGD("success to Unmarshalling profileCapabilityData");
+    return true;
+}
+
+}  // namespace Media
+}  // namespace OHOS
diff --git a/services/services/sa_media/ipc/recorder_profiles_parcel.h b/services/services/sa_media/ipc/recorder_profiles_parcel.h
new file mode 100644
index 0000000000000000000000000000000000000000..b2afb7a34c31136e802211845449687aa1a4532f
--- /dev/null
+++ b/services/services/sa_media/ipc/recorder_profiles_parcel.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECORDERPROFILES_PARCEL_H
+#define RECORDERPROFILES_PARCEL_H
+
+#include <vector>
+#include "message_parcel.h"
+#include "recorder_profiles.h"
+
+namespace OHOS {
+namespace Media {
+class RecorderProfilesParcel {
+public:
+    RecorderProfilesParcel() = delete;
+    ~RecorderProfilesParcel() = delete;
+
+    static bool Marshalling(
+        MessageParcel &parcel, const std::vector<RecorderProfilesData> &profileCapabilityDataArray);
+    static bool Marshalling(MessageParcel &parcel, const RecorderProfilesData &profileCapabilityData);
+
+    static bool Unmarshalling(
+        MessageParcel &parcel, std::vector<RecorderProfilesData> &profileCapabilityDataArray);
+    static bool Unmarshalling(MessageParcel &parcel, RecorderProfilesData &profileCapabilityData);
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // RECORDERPROFILES_PARCEL_H
diff --git a/services/services/sa_media/server/media_server.cpp b/services/services/sa_media/server/media_server.cpp
index 53302b9391b38da2d125c9bc0f265580aa4ea3ad..1674b907a83d17d961261fc30ec627b6034f96a7 100644
--- a/services/services/sa_media/server/media_server.cpp
+++ b/services/services/sa_media/server/media_server.cpp
@@ -79,6 +79,9 @@ sptr<IRemoteObject> MediaServer::GetSubSystemAbility(IStandardMediaService::Medi
         case MediaSystemAbility::MEDIA_AVCODEC: {
             return MediaServerManager::GetInstance().CreateStubObject(MediaServerManager::AVCODEC);
         }
+        case MediaSystemAbility::RECORDER_PROFILES: {
+            return MediaServerManager::GetInstance().CreateStubObject(MediaServerManager::RECORDERPROFILES);
+        }
         case MediaSystemAbility::MEDIA_AVMUXER: {
             return MediaServerManager::GetInstance().CreateStubObject(MediaServerManager::AVMUXER);
         }
diff --git a/services/services/sa_media/server/media_server_manager.cpp b/services/services/sa_media/server/media_server_manager.cpp
index 50037de5d8df983d8b1e497065f880afc87f37fd..5f05b366e16716f81f3628eedf3c0a28e18df447 100644
--- a/services/services/sa_media/server/media_server_manager.cpp
+++ b/services/services/sa_media/server/media_server_manager.cpp
@@ -19,6 +19,7 @@
 #include "player_service_stub.h"
 #include "avmetadatahelper_service_stub.h"
 #include "avcodeclist_service_stub.h"
+#include "recorder_profiles_service_stub.h"
 #include "avmuxer_service_stub.h"
 #include "media_log.h"
 #include "media_errors.h"
@@ -129,6 +130,9 @@ sptr<IRemoteObject> MediaServerManager::CreateStubObject(StubType type)
         case AVCODEC: {
             return CreateAVCodecStubObject();
         }
+        case RECORDERPROFILES: {
+            return CreateRecorderProfilesStubObject();
+        }
         case AVMUXER: {
             return CreateAVMuxerStubObject();
         }
@@ -283,6 +287,27 @@ sptr<IRemoteObject> MediaServerManager::CreateAVCodecStubObject()
     return object;
 }
 
+sptr<IRemoteObject> MediaServerManager::CreateRecorderProfilesStubObject()
+{
+    if (recorderProfilesStubMap_.size() >= SERVER_MAX_NUMBER) {
+        MEDIA_LOGE("The number of recorder_profiles services(%{public}zu) has reached the upper limit."
+            "Please release the applied resources.", recorderProfilesStubMap_.size());
+        return nullptr;
+    }
+    sptr<RecorderProfilesServiceStub> recorderProfilesStub = RecorderProfilesServiceStub::Create();
+    if (recorderProfilesStub == nullptr) {
+        MEDIA_LOGE("failed to create recorderProfilesStub");
+        return nullptr;
+    }
+    sptr<IRemoteObject> object = recorderProfilesStub->AsObject();
+    if (object != nullptr) {
+        pid_t pid = IPCSkeleton::GetCallingPid();
+        recorderProfilesStubMap_[object] = pid;
+        MEDIA_LOGD("The number of recorder_profiles services(%{public}zu).", recorderProfilesStubMap_.size());
+    }
+    return object;
+}
+
 sptr<IRemoteObject> MediaServerManager::CreateAVMuxerStubObject()
 {
     if (avmuxerStubMap_.size() >= SERVER_MAX_NUMBER) {
@@ -370,6 +395,18 @@ void MediaServerManager::DestroyStubObject(StubType type, sptr<IRemoteObject> ob
             MEDIA_LOGE("find avcodeclist object failed, pid(%{public}d).", pid);
             break;
         }
+        case RECORDERPROFILES: {
+            for (auto it = recorderProfilesStubMap_.begin(); it != recorderProfilesStubMap_.end(); it++) {
+                if (it->first == object) {
+                    MEDIA_LOGD("destroy mediaprofile stub services(%{public}zu) pid(%{public}d).",
+                        recorderProfilesStubMap_.size(), pid);
+                    (void)recorderProfilesStubMap_.erase(it);
+                    return;
+                }
+            }
+            MEDIA_LOGE("find mediaprofile object failed, pid(%{public}d).", pid);
+            break;
+        }
         case AVMUXER: {
             for (auto it = avmuxerStubMap_.begin(); it != avmuxerStubMap_.end(); it++) {
                 if (it->first == object) {
@@ -443,6 +480,16 @@ void MediaServerManager::DestroyStubObjectForPid(pid_t pid)
     }
     MEDIA_LOGD("avcodeclist stub services(%{public}zu).", avCodecListStubMap_.size());
 
+    MEDIA_LOGD("mediaprofile stub services(%{public}zu) pid(%{public}d).", recorderProfilesStubMap_.size(), pid);
+    for (auto itMediaProfile = recorderProfilesStubMap_.begin(); itMediaProfile != recorderProfilesStubMap_.end();) {
+        if (itMediaProfile->second == pid) {
+            itMediaProfile = recorderProfilesStubMap_.erase(itMediaProfile);
+        } else {
+            itMediaProfile++;
+        }
+    }
+    MEDIA_LOGD("mediaprofile stub services(%{public}zu).", recorderProfilesStubMap_.size());
+
     MEDIA_LOGD("avmuxer stub services(%{public}zu) pid(%{public}d).", avmuxerStubMap_.size(), pid);
     for (auto itAVMuxer = avmuxerStubMap_.begin(); itAVMuxer != avmuxerStubMap_.end();) {
         if (itAVMuxer->second == pid) {
diff --git a/services/services/sa_media/server/media_server_manager.h b/services/services/sa_media/server/media_server_manager.h
index b37688c5f84e814fa22e7ae1c27f5ff5ac79febe..140c4cbe082bd000aa1cefc16258408526d31ae7 100644
--- a/services/services/sa_media/server/media_server_manager.h
+++ b/services/services/sa_media/server/media_server_manager.h
@@ -46,6 +46,7 @@ public:
         AVCODECLIST,
         AVCODEC,
         AVMUXER,
+        RECORDERPROFILES,
     };
     sptr<IRemoteObject> CreateStubObject(StubType type);
     void DestroyStubObject(StubType type, sptr<IRemoteObject> object);
@@ -61,12 +62,14 @@ private:
     sptr<IRemoteObject> CreateAVMetadataHelperStubObject();
     sptr<IRemoteObject> CreateAVCodecListStubObject();
     sptr<IRemoteObject> CreateAVCodecStubObject();
+    sptr<IRemoteObject> CreateRecorderProfilesStubObject();
     sptr<IRemoteObject> CreateAVMuxerStubObject();
     std::map<sptr<IRemoteObject>, pid_t> recorderStubMap_;
     std::map<sptr<IRemoteObject>, pid_t> playerStubMap_;
     std::map<sptr<IRemoteObject>, pid_t> avMetadataHelperStubMap_;
     std::map<sptr<IRemoteObject>, pid_t> avCodecListStubMap_;
     std::map<sptr<IRemoteObject>, pid_t> avCodecStubMap_;
+    std::map<sptr<IRemoteObject>, pid_t> recorderProfilesStubMap_;
     std::map<sptr<IRemoteObject>, pid_t> avmuxerStubMap_;
     std::map<StubType, std::vector<Dumper>> dumperTbl_;
 
diff --git a/services/utils/BUILD.gn b/services/utils/BUILD.gn
index 8a450816538afb1724d743a04740dbb2b13ab18f..c495119216aed4e49e27901e53601ed345e14f35 100644
--- a/services/utils/BUILD.gn
+++ b/services/utils/BUILD.gn
@@ -14,16 +14,21 @@
 import("//build/ohos.gni")
 
 ohos_static_library("media_format") {
-  sources = [ "format.cpp" ]
+  sources = [
+    "format.cpp",
+    "xml_parse.cpp",
+  ]
 
   include_dirs = [
     "//foundation/multimedia/media_standard/interfaces/inner_api/native",
     "//foundation/multimedia/media_standard/services/utils/include",
     "//utils/native/base/include",
+    "//third_party/libxml2/include",
   ]
 
   deps = [
     "//foundation/multimedia/media_standard/services/utils:media_service_utils",
+    "//third_party/libxml2:xml2",
   ]
 
   external_deps = [ "hiviewdfx_hilog_native:libhilog" ]
@@ -50,11 +55,13 @@ ohos_shared_library("media_service_utils") {
     "time_monitor.cpp",
     "time_perf.cpp",
     "uri_helper.cpp",
+    "xml_parse.cpp",
   ]
 
   include_dirs = [
     "//utils/native/base/include",
     "//foundation/multimedia/media_standard/interfaces/inner_api/native",
+    "//third_party/libxml2/include",
   ]
 
   cflags = [
@@ -77,7 +84,10 @@ ohos_shared_library("media_service_utils") {
 
   configs = [ ":media_service_utils_public_config" ]
 
-  deps = [ "//utils/native/base:utils" ]
+  deps = [
+    "//third_party/libxml2:xml2",
+    "//utils/native/base:utils",
+  ]
 
   external_deps = [
     "hisysevent_native:libhisysevent",
diff --git a/services/utils/include/xml_parse.h b/services/utils/include/xml_parse.h
new file mode 100644
index 0000000000000000000000000000000000000000..307b227ae627f18136118d4f03eaca952f41f25c
--- /dev/null
+++ b/services/utils/include/xml_parse.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef XML_PARSE_H
+#define XML_PARSE_H
+
+#include <libxml/parser.h>
+#include <libxml/tree.h>
+#include <vector>
+#include <string>
+#include <unordered_map>
+#include "recorder_profiles.h"
+
+namespace OHOS {
+namespace Media {
+class XmlParser {
+public:
+    virtual ~XmlParser();
+    virtual bool LoadConfiguration(const char *xmlPath) final;
+    virtual bool Parse() final;
+    virtual void Destroy() final;
+    virtual std::vector<RecorderProfilesData> GetRecorderProfileDataArray() = 0;
+
+protected:
+    xmlDoc *mDoc_ = nullptr;
+    virtual bool ParseInternal(xmlNode *node) = 0;
+    virtual bool SetCapabilityIntData(std::unordered_map<std::string, int32_t&> dataMap,
+        const std::string &capabilityKey, const std::string &capabilityValue) const = 0;
+    virtual bool SetCapabilityVectorData(std::unordered_map<std::string, std::vector<int32_t>&> dataMap,
+        const std::string &capabilityKey, const std::string &capabilityValue) const = 0;
+    virtual bool IsNumberArray(const std::vector<std::string> &strArray) const final;
+    virtual bool TransStrAsRange(const std::string &str, Range &range) const final;
+    virtual std::vector<int32_t> TransMapAsIntegerArray(
+        const std::unordered_map<std::string, int> &capabilityMap, const std::vector<std::string> &spilt) const final;
+    virtual std::vector<int32_t> TransStrAsIntegerArray(const std::vector<std::string> &spilt) const final;
+    virtual bool SpiltKeyList(
+        const std::string &str, const std::string &delim, std::vector<std::string> &spilt) const final;
+    virtual bool SetCapabilityStringData(std::unordered_map<std::string, std::string&> dataMap,
+        const std::string &capabilityKey, const std::string &capabilityValue) const final;
+    virtual bool SetCapabilityBoolData(std::unordered_map<std::string, bool&> dataMap,
+        const std::string &capabilityKey, const std::string &capabilityValue) const final;
+    virtual bool SetCapabilityRangeData(std::unordered_map<std::string, Range&> dataMap,
+        const std::string &capabilityKey, const std::string &capabilityValue) const final;
+};
+}  //  namespace Media
+}  //  namespace OHOS
+
+#endif  //  XML_PARSE_H
\ No newline at end of file
diff --git a/services/utils/xml_parse.cpp b/services/utils/xml_parse.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..61222665d57457d4d4af8654ee000a385034b970
--- /dev/null
+++ b/services/utils/xml_parse.cpp
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "xml_parse.h"
+#include "media_errors.h"
+#include "media_log.h"
+#include "string_ex.h"
+
+namespace {
+    constexpr OHOS::HiviewDFX::HiLogLabel LABEL = {LOG_CORE, LOG_DOMAIN, "XmlParser"};
+}
+
+namespace OHOS {
+namespace Media {
+XmlParser::~XmlParser()
+{
+    Destroy();
+    MEDIA_LOGD("0x%{public}06" PRIXPTR " Instances destroy", FAKE_POINTER(this));
+}
+
+bool XmlParser::LoadConfiguration(const char *xmlPath)
+{
+    mDoc_ = xmlReadFile(xmlPath, NULL, 0);
+    if (mDoc_ == NULL) {
+        MEDIA_LOGE("XmlParser xmlReadFile failed");
+        return false;
+    }
+    return true;
+}
+
+bool XmlParser::Parse()
+{
+    xmlNode *root = xmlDocGetRootElement(mDoc_);
+    if (root == NULL) {
+        MEDIA_LOGE("XmlParser xmlDocGetRootElement failed");
+        return false;
+    }
+    return ParseInternal(root);
+}
+
+void XmlParser::Destroy()
+{
+    if (mDoc_ != NULL) {
+        xmlFreeDoc(mDoc_);
+    }
+    return;
+}
+
+bool XmlParser::IsNumberArray(const std::vector<std::string> &strArray) const
+{
+    for (auto iter = strArray.begin(); iter != strArray.end(); iter++) {
+        for (char const &c : *iter) {
+            if (std::isdigit(c) == 0) {
+                return false;
+            }
+        }
+    }
+    return true;
+}
+
+bool XmlParser::TransStrAsRange(const std::string &str, Range &range) const
+{
+    if (str == "null" || str == "") {
+        MEDIA_LOGD("str is null");
+        return false;
+    }
+    size_t pos = str.find("-");
+    if (pos != str.npos && pos + 1 < str.size()) {
+        std::string head = str.substr(0, pos);
+        std::string tail = str.substr(pos + 1);
+        if (!StrToInt(head, range.minVal)) {
+            MEDIA_LOGE("call StrToInt func false, input str is: %{public}s", head.c_str());
+            return false;
+        }
+        if (!StrToInt(tail, range.maxVal)) {
+            MEDIA_LOGE("call StrToInt func false, input str is: %{public}s", tail.c_str());
+            return false;
+        }
+    } else {
+        MEDIA_LOGD("Can not find the delimiter of \"-\" in : %{public}s", str.c_str());
+        return false;
+    }
+    return true;
+}
+
+std::vector<int32_t> XmlParser::TransMapAsIntegerArray(
+    const std::unordered_map<std::string, int> &capabilityMap,
+    const std::vector<std::string> &spilt) const
+{
+    std::vector<int32_t> res;
+    for (auto iter = spilt.begin(); iter != spilt.end(); iter++) {
+        if (capabilityMap.find(*iter) != capabilityMap.end()) {
+            res.emplace_back(capabilityMap.at(*iter));
+        } else {
+            MEDIA_LOGD("can not find %{public}s in capabilityMap", iter->c_str());
+        }
+    }
+    return res;
+}
+
+std::vector<int32_t> XmlParser::TransStrAsIntegerArray(const std::vector<std::string> &spilt) const
+{
+    std::vector<int32_t> array;
+    for (auto iter = spilt.begin(); iter != spilt.end(); iter++) {
+        int32_t num = -1;
+        if (!StrToInt(*iter, num)) {
+            MEDIA_LOGE("call StrToInt func false, input str is: %{public}s", iter->c_str());
+            return array;
+        }
+        array.push_back(num);
+    }
+    return array;
+}
+
+bool XmlParser::SpiltKeyList(const std::string &str, const std::string &delim,
+    std::vector<std::string> &spilt) const
+{
+    if (str == "") {
+        return false;
+    }
+    std::string strAddDelim = str;
+    if (str.back() != delim.back()) {
+        strAddDelim = str + delim;
+    }
+    size_t pos = 0;
+    size_t size = strAddDelim.size();
+    for (size_t i = 0; i < size; ++i) {
+        pos = strAddDelim.find(delim, i);
+        if (pos != strAddDelim.npos) {
+            std::string s = strAddDelim.substr(i, pos - i);
+            spilt.push_back(s);
+            i = pos + delim.size() - 1;
+        }
+    }
+    return true;
+}
+
+bool XmlParser::SetCapabilityStringData(std::unordered_map<std::string, std::string&> dataMap,
+    const std::string &capabilityKey, const std::string &capabilityValue) const
+{
+    dataMap.at(capabilityKey) = capabilityValue;
+    return true;
+}
+
+bool XmlParser::SetCapabilityBoolData(std::unordered_map<std::string, bool&> dataMap,
+    const std::string &capabilityKey, const std::string &capabilityValue) const
+{
+    if (capabilityValue == "true") {
+        dataMap.at(capabilityKey) = true;
+    } else if (capabilityValue == "false") {
+        dataMap.at(capabilityKey) = false;
+    } else {
+        MEDIA_LOGD("The value of %{public}s in the configuration file is incorrect.", capabilityValue.c_str());
+        return false;
+    }
+    return true;
+}
+
+bool XmlParser::SetCapabilityRangeData(std::unordered_map<std::string, Range&> dataMap,
+    const std::string &capabilityKey, const std::string &capabilityValue) const
+{
+    Range range;
+    bool ret = TransStrAsRange(capabilityValue, range);
+    CHECK_AND_RETURN_RET_LOG(ret != false, false, "failed:can not trans %{public}s", capabilityValue.c_str());
+    dataMap.at(capabilityKey) = range;
+    return true;
+}
+}  // namespace Media
+}  // namespace OHOS
\ No newline at end of file
diff --git a/test/nativedemo/BUILD.gn b/test/nativedemo/BUILD.gn
index d93e83d8756b49f884af06a93c3f027c52bc7d13..3c89d6004691057af289e3891d8468552a8651c1 100644
--- a/test/nativedemo/BUILD.gn
+++ b/test/nativedemo/BUILD.gn
@@ -21,6 +21,7 @@ ohos_executable("media_demo") {
     "./recorder",
     "./avmetadatahelper",
     "./avcodeclist",
+    "./recorder_profiles",
     "./avcodecvenc",
     "./avcodecvdec",
     "./avmuxer",
@@ -55,6 +56,7 @@ ohos_executable("media_demo") {
 
   sources = [
     "./avcodeclist/avcodeclist_demo.cpp",
+    "./recorder_profiles/recorder_profiles_demo.cpp",
     "./avcodecvdec/avcodec_vdec_demo.cpp",
     "./avcodecvenc/avcodec_venc_demo.cpp",
     "./avmetadatahelper/avmetadatahelper_demo.cpp",
diff --git a/test/nativedemo/media_demo.cpp b/test/nativedemo/media_demo.cpp
index bee12f0a688ae89e0a50413f26a7fd1747eca136..d4615ed687d3b6f79547b0f5fd44301a62f3571c 100644
--- a/test/nativedemo/media_demo.cpp
+++ b/test/nativedemo/media_demo.cpp
@@ -21,6 +21,7 @@
 #include "avcodeclist_demo.h"
 #include "avcodec_venc_demo.h"
 #include "avcodec_vdec_demo.h"
+#include "recorder_profiles_demo.h"
 #include "avmuxer_demo.h"
 
 using namespace OHOS;
@@ -88,6 +89,18 @@ static int RunVideoEncoder(bool enableProp)
     return 0;
 }
 
+static int RunMediaProfile(const string &path)
+{
+    auto profile = std::make_unique<RecorderProfilesDemo>();
+    if (profile == nullptr) {
+        cout << "mediaprofile is null" << endl;
+        return 0;
+    }
+    profile->RunCase(path);
+    cout << "demo mediaprofile end" << endl;
+    return 0;
+}
+
 static int RunAVMuxer()
 {
     auto avmuxer = std::make_unique<AVMuxerDemo>();
@@ -114,6 +127,8 @@ int main(int argc, char *argv[])
     cout << "3:codeclist" << endl;
     cout << "4:video-encoder" << endl;
     cout << "5:avmuxer" << endl;
+    cout << "6:recorder_profiles" << endl;
+
     string mode;
     (void)getline(cin, mode);
     if (mode == "" || mode == "0") {
@@ -128,6 +143,8 @@ int main(int argc, char *argv[])
         (void)RunVideoEncoder(false);
     } else if (mode == "5") {
         (void)RunAVMuxer();
+    } else if (mode == "6") {
+        (void)RunMediaProfile(path);
     } else {
         cout << "no that selection" << endl;
     }
diff --git a/test/nativedemo/recorder_profiles/recorder_profiles_demo.cpp b/test/nativedemo/recorder_profiles/recorder_profiles_demo.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..258c363a4e291cd0e9cf82d0b4373d3ff961d7f4
--- /dev/null
+++ b/test/nativedemo/recorder_profiles/recorder_profiles_demo.cpp
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "avmuxer_demo.h"
+#include "recorder_profiles_demo.h"
+#include <iostream>
+#include "media_errors.h"
+#include "string_ex.h"
+
+using namespace std;
+
+namespace OHOS {
+namespace Media {
+void RecorderProfilesDemo::DoNext()
+{
+    cout << "Enter your step:" << endl;
+    std::string cmd;
+    bool result;
+    cout << "Please select a test api: " << endl;
+    cout << "1:IsAudioRecoderConfigSupported" << endl;
+    cout << "2:HasVideoRecorderProfile" << endl;
+    cout << "3:GetAudioRecorderCaps" << endl;
+    cout << "4:GetVideoRecorderCaps" << endl;
+    cout << "5:GetVideoRecorderProfile" << endl;
+    cout << "6:GetAVMuxerFormatList" << endl;
+    while (std::getline(std::cin, cmd)) {
+        if (cmd.find("1") != std::string::npos || cmd.find("IsAudioRecoderConfigSupported") != std::string::npos) {
+            if (CreatProfile()) {
+                result = OHOS::Media::RecorderProfilesFactory::CreateRecorderProfiles().IsAudioRecoderConfigSupported(
+                    *profile_);
+                cout << "IsAudioRecoderConfigSupported : " << result << endl;
+                profile_ = nullptr;
+            }
+        } else if (cmd.find("2") != std::string::npos || cmd.find("HasVideoRecorderProfile") != std::string::npos) {
+            if (BuildSourceId()) {
+                result = OHOS::Media::RecorderProfilesFactory::CreateRecorderProfiles().HasVideoRecorderProfile(
+                    sourceId_, qualityLevel_);
+                cout << "HasVideoRecorderProfile : " << result<< endl;
+            }
+        }else if (cmd.find("3") != std::string::npos || cmd.find("AudioRecorderCaps") != std::string::npos) {
+            std::vector<std::shared_ptr<AudioRecorderCaps>> audioRecorderArray =
+                OHOS::Media::RecorderProfilesFactory::CreateRecorderProfiles().GetAudioRecorderCaps();
+            PrintAudioRecorderCapsArray(audioRecorderArray);
+        } else if (cmd.find("4") != std::string::npos || cmd.find("GetVideoRecorderCaps") != std::string::npos) {
+            std::vector<std::shared_ptr<VideoRecorderCaps>> videoRecorderArray =
+                OHOS::Media::RecorderProfilesFactory::CreateRecorderProfiles().GetVideoRecorderCaps();
+            PrintVideoRecorderCapsArray(videoRecorderArray);
+        } else if (cmd.find("5") != std::string::npos || cmd.find("GetVideoRecorderProfile") != std::string::npos) {
+            if (BuildSourceId()) {
+                std::shared_ptr<VideoRecorderProfile> videoRecorderProfile =
+                    OHOS::Media::RecorderProfilesFactory::CreateRecorderProfiles().GetVideoRecorderProfile(
+                        sourceId_, qualityLevel_);
+                PrintVideoRecorderProfile(videoRecorderProfile);
+            }
+        } else if (cmd.find("6") != std::string::npos || cmd.find("GetAVMuxerFormatList") != std::string::npos) {
+            std::vector<std::string> muxerFormatList =
+                    OHOS::Media::AVMuxerFactory::CreateAVMuxer()->GetAVMuxerFormatList();
+            PrintMuxerFormatList(muxerFormatList);
+        }
+    }
+}
+
+bool RecorderProfilesDemo::CreatProfile()
+{
+    cout << "please input the AudioRecoderConfig."<< endl;
+    profile_  = std::make_shared<AudioRecorderProfile>();
+    bool ret = true;
+    ret = (ret && SetStringParamValue("containerFormatType"));
+    ret = (ret && SetStringParamValue("audioCodec"));
+    ret = (ret && SetIntParamValue("audioBitrate"));
+    ret = (ret && SetIntParamValue("audioSampleRate"));
+    ret = (ret && SetIntParamValue("audioChannels"));
+    return ret;
+}
+
+bool RecorderProfilesDemo::BuildSourceId()
+{
+    bool ret = true;
+    ret = (ret && SetIntParamValue("sourceId"));
+    ret = (ret && SetIntParamValue("qualityLevel"));
+    return ret;
+}
+
+bool RecorderProfilesDemo::SetIntParamValue(const std::string &strKey)
+{
+    cout << "please input the " << strKey <<" :"<< endl;
+    std::string inputValue = "";
+    (void)getline(cin, inputValue);
+    if (inputValue == "") {
+        cout << "input value is null" << endl;
+        return false;
+    }
+
+    int32_t number = -1;
+    if (!StrToInt(inputValue, number)) {
+        cout << "call StrToInt func false, input str is:" << inputValue.c_str();
+        return false;
+    }
+
+    if ("sourceId" == strKey) {
+        sourceId_ = number;
+    } else if ("qualityLevel" == strKey) {
+        qualityLevel_ = number;
+    } else if ("audioBitrate" == strKey) {
+        profile_->audioBitrate = number;
+    } else if ("audioSampleRate" == strKey) {
+        profile_->audioSampleRate = number;
+    } else if ("audioChannels" == strKey) {
+        profile_->audioChannels = number;
+    } else {
+        cout << "input wrong key" << endl;
+    }
+
+    cin.clear();
+    return true;
+}
+
+bool RecorderProfilesDemo::SetStringParamValue(const std::string &strKey)
+{
+    cout << "please input the " << strKey <<" :"<< endl;
+    std::string inputValue = "";
+    (void)getline(cin, inputValue);
+    if (inputValue == "") {
+        cout << "input value is null" << endl;
+        return false;
+    }
+
+    if ("containerFormatType" == strKey) {
+        profile_->containerFormatType = inputValue;
+    } else if ("audioCodec" == strKey) {
+        profile_->audioCodec = inputValue;
+    } else {
+        cout << "input wrong key" << endl;
+    }
+
+    cin.clear();
+    return true;
+}
+
+void RecorderProfilesDemo::PrintAudioRecorderCapsArray(
+    const std::vector<std::shared_ptr<AudioRecorderCaps>> &audioRecorderArray) const
+{
+    for (auto iter = audioRecorderArray.begin(); iter != audioRecorderArray.end(); iter++) {
+        std::shared_ptr<AudioRecorderCaps> pAudioRecorderCaps = *iter;
+        cout << "GetContainerFormatType =" <<  pAudioRecorderCaps->containerFormatType << endl;
+        cout << "GetMimeType = "<<  pAudioRecorderCaps->mimeType << endl;
+        cout << "GetSupportedBitrate = "<< pAudioRecorderCaps->bitrate.minVal <<\
+                " - " << pAudioRecorderCaps->bitrate.maxVal << endl;
+        cout << "GetSupportedChannel = "<< pAudioRecorderCaps->channels.minVal <<\
+                " - " << pAudioRecorderCaps->channels.maxVal << endl;
+        PrintIntArray(pAudioRecorderCaps->sampleRate, "GetSupportedSampleRates");
+    }
+}
+
+void RecorderProfilesDemo::PrintVideoRecorderCapsArray(
+    const std::vector<std::shared_ptr<VideoRecorderCaps>> &videoRecorderArray) const
+{
+    for (auto iter =  videoRecorderArray.begin(); iter !=  videoRecorderArray.end(); iter++) {
+        std::shared_ptr< VideoRecorderCaps> pVideoRecorderCaps = *iter;
+        cout << "GetContainerFormatType =" <<  pVideoRecorderCaps->containerFormatType << endl;
+        cout << "GetAudioEncoderMime = " << pVideoRecorderCaps->audioEncoderMime << endl;
+        cout << "GetVideoEncoderMime = " <<  pVideoRecorderCaps->videoEncoderMime <<endl;
+        cout << "GetSupportedAudioBitrate = "<< pVideoRecorderCaps->audioBitrateRange.minVal <<\
+                " - " << pVideoRecorderCaps->audioBitrateRange.maxVal << endl;
+        cout << "GetSupportedChannel = "<< pVideoRecorderCaps->audioChannelRange.minVal <<\
+                " - " << pVideoRecorderCaps->audioChannelRange.maxVal << endl;
+        cout << "GetSupportedVideoBitrate = "<< pVideoRecorderCaps->videoBitrateRange.minVal <<\
+                " - "<< pVideoRecorderCaps->videoBitrateRange.maxVal << endl;
+        cout << "GetSupportedVideoFramerate = "<< pVideoRecorderCaps->videoFramerateRange.minVal <<\
+                " - "<< pVideoRecorderCaps->videoFramerateRange.maxVal << endl;
+        cout << "GetSupportedVideoWidthRange = "<< pVideoRecorderCaps->videoWidthRange.minVal <<\
+                " - "<< pVideoRecorderCaps->videoWidthRange.maxVal << endl;
+        cout << "GetSupportedVideoHeightRange = "<< pVideoRecorderCaps->videoHeightRange.minVal <<\
+                " - "<< pVideoRecorderCaps->videoHeightRange.maxVal << endl;
+        PrintIntArray(pVideoRecorderCaps->audioSampleRates, "GetSupportedSampleRates");
+    }
+}
+
+void RecorderProfilesDemo::PrintMuxerFormatList(
+    const std::vector<std::string> &formatList) const
+{
+    int count = 0;
+    cout << "MuxerFormat" << ": " << endl;
+    for (auto iter = formatList.begin(); iter != formatList.end(); iter++) {
+        count++;
+        cout << count <<":" << *iter << ", " << endl;
+    }
+    cout  << endl;
+}
+
+void RecorderProfilesDemo::PrintVideoRecorderProfile(
+    const std::shared_ptr<VideoRecorderProfile> &videoRecorderProfile) const
+{
+        cout << "GetContainerFormatType =" <<  videoRecorderProfile->containerFormatType << endl;
+        cout << "GetAudioBitrate = "<< videoRecorderProfile->audioBitrate << endl;
+        cout << "GetAudioChannels = " << videoRecorderProfile->audioChannels<< endl;
+        cout << "GetAudioCodec = " <<  videoRecorderProfile->audioCodec <<endl;
+        cout << "GetAudioSampleRate = "<< videoRecorderProfile->audioSampleRate << endl;
+        cout << "GetDurationTime = "<< videoRecorderProfile->durationTime << endl;
+        cout << "GetQualityLevel = "<< videoRecorderProfile->qualityLevel << endl;
+        cout << "GetVideoBitrate = "<< videoRecorderProfile->videoBitrate << endl;
+        cout << "GetVideoCodec = "<< videoRecorderProfile->videoCodec << endl;
+        cout << "GetVideoFrameWidth = "<< videoRecorderProfile->videoFrameWidth << endl;
+        cout << "GetVideoFrameHeight = "<< videoRecorderProfile->videoFrameHeight << endl;
+        cout << "GetVideoFrameRate = "<< videoRecorderProfile->videoFrameRate << endl;
+}
+
+void RecorderProfilesDemo::PrintIntArray(const std::vector<int32_t> &array, const std::string &logmsg) const
+{
+    cout << logmsg << ": ";
+    for (auto iter = array.begin(); iter != array.end(); iter++) {
+        cout << *iter << ", ";
+    }
+    cout  << endl;
+}
+
+void RecorderProfilesDemo::RunCase(const string &path)
+{
+    DoNext();
+}
+}  // namespace Media
+}  // namespace OHOS
\ No newline at end of file
diff --git a/test/nativedemo/recorder_profiles/recorder_profiles_demo.h b/test/nativedemo/recorder_profiles/recorder_profiles_demo.h
new file mode 100644
index 0000000000000000000000000000000000000000..70fff8d66dc773507826f1d04cacc563850b7ad8
--- /dev/null
+++ b/test/nativedemo/recorder_profiles/recorder_profiles_demo.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RECORDERPROFILES_DEMO_H
+#define RECORDERPROFILES_DEMO_H
+
+#include "securec.h"
+#include "nocopyable.h"
+#include "recorder_profiles.h"
+
+namespace OHOS {
+namespace Media {
+class RecorderProfilesDemo : public NoCopyable {
+public:
+    RecorderProfilesDemo() = default;
+    virtual ~RecorderProfilesDemo() = default;
+
+    void RunCase(const std::string &path);
+    void DoNext();
+private:
+    int32_t sourceId_ = 0;
+    int32_t qualityLevel_ = 0;
+    std::shared_ptr<AudioRecorderProfile> profile_;
+    void PrintAudioRecorderCapsArray(const std::vector<std::shared_ptr<AudioRecorderCaps>> &audioRecorderArray) const;
+    void PrintVideoRecorderCapsArray(const std::vector<std::shared_ptr<VideoRecorderCaps>> &videoRecorderArray) const;
+    void PrintVideoRecorderProfile(const std::shared_ptr<VideoRecorderProfile> &videoRecorderProfile) const;
+    void PrintIntArray(const std::vector<int32_t> &array, const std::string &logmsg) const;
+    void PrintMuxerFormatList(const std::vector<std::string> &formatList) const;
+
+    bool BuildSourceId();
+    bool CreatProfile();
+    bool SetIntParamValue(const std::string &strKey);
+    bool SetStringParamValue(const std::string &strKey);
+};
+}  // namespace Media
+}  // namespace OHOS
+#endif  // RECORDERPROFILES_DEMO_H
\ No newline at end of file
